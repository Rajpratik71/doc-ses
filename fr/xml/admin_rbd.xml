<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_rbd.xml" version="5.0" xml:id="ceph-rbd">
 <title>Périphérique de traitement par blocs RADOS</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:translation>oui</dm:translation>
        <dm:release>SES 5</dm:release>
      </dm:docmanager>
    </info>
    <para>
  Un bloc est une séquence d'octets, par exemple un bloc de 512 octets de données. Les interfaces de stockage basées sur des blocs constituent le moyen le plus courant de stocker des données sur des supports rotatifs, tels que des disques durs, des CD ou des disquettes. L'omniprésence des interfaces de périphériques de traitement par blocs fait d'un périphérique virtuel un candidat idéal pour interagir avec un système de stockage de données de masse, tel que Ceph.
 </para>
 <para>
  Les périphériques de traitement par blocs Ceph permettent le partage de ressources physiques et sont redimensionnables. Ils stockent les données réparties sur plusieurs OSD dans une grappe Ceph. Les périphériques de traitement par blocs Ceph exploitent les fonctions RADOS, telles que les instantanés, la réplication et la cohérence. Les RBD (RADOS Block Devices) de Ceph interagissent avec les OSD utilisant des modules de kernel ou la bibliothèque <systemitem>librbd</systemitem>.
 </para>
 <figure>
  <title>Protocole RADOS</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata fileref="ceph_rbd_schema.png" width="70%" format="PNG"/>
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="ceph_rbd_schema.png" width="70%" format="PNG"/>
   </imageobject>
  </mediaobject>
 </figure>
 <para>
  Les périphériques de traitement par blocs de Ceph offrent des performances exceptionnelles ainsi qu'une évolutivité infinie des modules du kernel. Ils prennent en charge des solutions de virtualisation, telles que QEMU, ou des systèmes basés sur le cloud, tels qu'OpenStack, qui reposent sur <systemitem class="library">libvirt</systemitem>. Vous pouvez utiliser la même grappe pour faire fonctionner Object Gateway, CephFS et les périphériques de traitement par blocs RADOS simultanément.
 </para>
 <sect1 xml:id="ceph-rbd-commands">
  <title>Commandes de périphériques de traitement par blocs</title>

  <para>
   La commande <command>rbd</command> vous permet de créer, de répertorier, d'explorer et de supprimer des images de périphérique de traitement par blocs. Vous pouvez également l'utiliser, par exemple, pour cloner des images, créer des instantanés, restaurer une image dans un instantané ou afficher un instantané.
  </para>

  <tip>
   <title>accès à une grappe</title>
   <para>
    Pour utiliser les commandes de périphérique de traitement par blocs RADOS, vous devez avoir accès à une grappe Ceph en cours d'exécution.
   </para>
  </tip>

  <sect2 xml:id="ceph-rbd-cmds-create">
   <title>Création d'une image de périphérique par blocs</title>
   <para>
    Pour pouvoir ajouter un périphérique de traitement par blocs pour un noeud, vous devez préalablement créer une image pour celui-ci dans la grappe. Pour créer une image de périphérique de traitement par blocs, exécutez la commande suivante :
   </para>
<screen><prompt>root # </prompt>rbd create --size <replaceable>megabytes</replaceable> <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable></screen>
   <para>
    Par exemple, pour créer une image de 1 Go nommée « bar » qui stocke des informations dans une réserve nommée « swimmingpool », exécutez la commande suivante :
   </para>
<screen><prompt>root # </prompt>rbd create --size 1024 swimmingpool/bar</screen>
   <tip>
    <title>réserve par défaut</title>
    <para>
     Si vous ne spécifiez pas de réserve lors de la création d'une image, celle-ci sera stockée dans la réserve par défaut « rbd ».
    </para>
   </tip>
   <note>
    <title>création préalable d'une réserve</title>
    <para>
     Vous devez d'abord créer une réserve avant de pouvoir la spécifier comme source. Pour plus d'informations, reportez-vous au <xref linkend="ceph-pools"/>.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="ceph-rbd-cmds-create-ec">
   <title>Création d'une image de périphérique de traitement par blocs dans une réserve codée à effacement</title>
   <para>
    À partir de SUSE Enterprise Storage 5, il est possible de stocker les données d'une image de périphérique de traitement par blocs dans des réserves codées à effacement. Seule la partie « données » d'une image RBD peut être stockée dans un réserve codée à effacement. En outre, l'indicateur « overwrite » de la réserve codée à effacement doit être défini sur <emphasis>true</emphasis>, ce qui est possible uniquement si tous les OSD utilisent BlueStore.<emphasis/>
   </para>
   <para>
    Les métadonnées d'image ne peuvent pas résider dans une réserve codée à effacement. Les métadonnées peuvent résider soit dans la réserve « rbd », soit dans la réserve que l'utilisateur indique explicitement avec le paramètre <parameter>--pool=</parameter> dans la commande <command>rbd create</command>.
   </para>
   <note>
    <title>BlueStore requis</title>
    <para>
     Tous les noeuds requièrent que BlueStore utilise des réserves codées à effacement pour les images de périphériques de traitement par blocs.
    </para>
   </note>
   <para>
    Utilisez les étapes suivantes pour créer une image RBD dans un réserve codée à effacement :
   </para>
<screen><prompt>root # </prompt><command>ceph</command> osd pool create <replaceable>POOL_NAME</replaceable> 12 12 erasure
<prompt>root # </prompt><command>ceph</command> osd pool set <replaceable>POOL_NAME</replaceable> allow_ec_overwrites true

# Metadata will reside in pool "rbd", and data in pool "<replaceable>POOL_NAME</replaceable>"
<prompt>root # </prompt><command>rbd</command> create <replaceable>IMAGE_NAME</replaceable> --size=1G --data-pool <replaceable>POOL_NAME</replaceable>

#Metadata will reside in pool "<replaceable>OTHER_POOL</replaceable>", and data in pool "<replaceable>POOL_NAME</replaceable>"
<prompt>root # </prompt><command>rbd</command> create <replaceable>IMAGE_NAME</replaceable> --size=1G --data-pool <replaceable>POOL_NAME</replaceable> --pool=<replaceable>OTHER_POOL</replaceable></screen>
  </sect2>

  <sect2 xml:id="ceph-rbd-cmds-list">
   <title>Liste des images de périphériques de traitement par blocs</title>
   <para>
    Pour répertorier les périphériques de traitement par blocs dans la réserve « rbd », exécutez la commande suivante (« rbd » est le nom de réserve par défaut) :
   </para>
<screen><prompt>root # </prompt>rbd ls</screen>
   <para>
    Pour répertorier les périphériques de traitement par blocs dans une réserve nommée « swimmingpool », exécutez la commande suivante :
   </para>
<screen><prompt>root # </prompt>rbd ls swimmingpool</screen>
  </sect2>

  <sect2 xml:id="ceph-rbd-cmds-info">
   <title>Récupération d'informations sur l'image</title>
   <para>
    Pour récupérer des informations à partir d'une image « bar » dans une réserve nommée « swimmingpool », exécutez la commande suivante :
   </para>
<screen><prompt>root # </prompt>rbd info swimmingpool/bar</screen>
  </sect2>

  <sect2 xml:id="ceph-rbd-cmds-resize">
   <title>Redimensionnement d'une image de périphérique de traitement par blocs</title>
   <para>
    Les images de périphérique de traitement par blocs RADOS sont provisionnées de façon légère : en effet, elles n'utilisent aucun stockage physique tant que vous n'y avez pas enregistré des données. Cependant, elles possèdent une capacité maximale que vous définissez à l'aide de l'option <option>--size</option>. Si vous souhaitez augmenter (ou diminuer) la taille maximale de l'image, exécutez la commande suivante :
   </para>
<screen><prompt>root # </prompt>rbd resize --size 2048 foo # to increase
rbd resize --size 2048 foo --allow-shrink # to decrease</screen>
  </sect2>

  <sect2 xml:id="ceph-rbd-cmds-rm">
   <title>Suppression d'une image de périphérique de traitement par blocs</title>
   <para>
    Pour supprimer un périphérique de traitement par blocs qui correspond à une image « bar » dans une réserve nommée « swimmingpool », exécutez la commande suivante :
   </para>
<screen><prompt>root # </prompt>rbd rm swimmingpool/bar</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="storage-bp-integration-mount-rbd">
  <title>Montage et démontage d'images RBD</title>

  <para>
   Après avoir créé un périphérique de traitement par blocs RADOS, vous pouvez le formater, le monter pour pouvoir échanger des fichiers et le démonter une fois que vous avez terminé.
  </para>

  <procedure>
   <step>
    <para>
     Assurez-vous que votre grappe Ceph inclut une réserve avec l'image disque que vous souhaitez monter. Supposons que la réserve soit appelée <literal>mypool</literal> et l'image <literal>myimage</literal>.
    </para>
<screen>rbd list mypool</screen>
   </step>
   <step>
    <para>
     Assignez l'image à un nouveau périphérique de traitement par blocs.
    </para>
<screen><prompt>root # </prompt>rbd map --pool mypool myimage</screen>
    <tip>
     <title>nom d'utilisateur et authentification</title>
     <para>
      Pour indiquer un nom d'utilisateur, utilisez <option>--id <replaceable>nom-utilisateur</replaceable></option>. En outre, si vous utilisez l'authentification <systemitem>cephx</systemitem>, vous devez également indiquer un secret. Il peut provenir d'un trousseau de clés ou d'un fichier contenant le secret :
     </para>
<screen><prompt>root # </prompt>rbd map --pool rbd myimage --id admin --keyring /path/to/keyring</screen>
     <para>
      ou
     </para>
<screen><prompt>root # </prompt>rbd map --pool rbd myimage --id admin --keyfile /path/to/file</screen>
    </tip>
   </step>
   <step>
    <para>
     Dressez la liste de tous les périphériques assignés :
    </para>
<screen><prompt>root # </prompt>rbd showmapped
 id pool   image   snap device
 0  mypool myimage -    /dev/rbd0</screen>
    <para>
     Le périphérique sur lequel nous voulons travailler est <filename>/dev/rbd0</filename>.
    </para>
   </step>
   <step>
    <para>
     Créez un système de fichiers XFS sur le périphérique <filename>/dev/rbd0</filename>.
    </para>
<screen><prompt>root # </prompt>mkfs.xfs /dev/rbd0
 log stripe unit (4194304 bytes) is too large (maximum is 256KiB)
 log stripe unit adjusted to 32KiB
 meta-data=/dev/rbd0              isize=256    agcount=9, agsize=261120 blks
          =                       sectsz=512   attr=2, projid32bit=1
          =                       crc=0        finobt=0
 data     =                       bsize=4096   blocks=2097152, imaxpct=25
          =                       sunit=1024   swidth=1024 blks
 naming   =version 2              bsize=4096   ascii-ci=0 ftype=0
 log      =internal log           bsize=4096   blocks=2560, version=2
          =                       sectsz=512   sunit=8 blks, lazy-count=1
 realtime =none                   extsz=4096   blocks=0, rtextents=0</screen>
   </step>
   <step>
    <para>
     Montez le périphérique et vérifiez qu'il est correctement monté. Remplacez <filename>/mnt</filename> par votre point de montage.
    </para>
<screen><prompt>root # </prompt>mount /dev/rbd0 /mnt
<prompt>root # </prompt>mount | grep rbd0
/dev/rbd0 on /mnt type xfs (rw,relatime,attr2,inode64,sunit=8192,...</screen>
    <para>
     Vous pouvez maintenant déplacer des données vers et depuis le périphérique comme s'il s'agissait d'un répertoire local.
    </para>
    <tip>
     <title>augmentation de la taille du périphérique RBD</title>
     <para>
      Si vous trouvez que la taille du périphérique RBD n'est plus suffisante, vous pouvez facilement l'augmenter.
     </para>
     <orderedlist spacing="normal">
      <listitem>
       <para>
        Augmentez la taille de l'image RBD, par exemple jusqu'à 10 Go.
       </para>
<screen><prompt>root # </prompt>rbd resize --size 10000 mypool/myimage
 Resizing image: 100% complete...done.</screen>
      </listitem>
      <listitem>
       <para>
        Développez le système de fichiers à la nouvelle taille du périphérique.
       </para>
<screen><prompt>root # </prompt>xfs_growfs /mnt
 [...]
 data blocks changed from 2097152 to 2560000</screen>
      </listitem>
     </orderedlist>
    </tip>
   </step>
   <step>
    <para>
     Après avoir accédé au périphérique, vous pouvez le démonter.
    </para>
<screen><prompt>root # </prompt>unmount /mnt</screen>
   </step>
  </procedure>

  <tip>
   <title>montage et démontage manuels</title>
   <para>
    Comme il est fastidieux d'assigner et de monter manuellement les images RBD après leur démarrage, leur démontage et leur désassignation avant la fermeture, un script <command>rbdmap</command> et une unité <systemitem class="daemon">systemd</systemitem> sont fournis. Reportez-vous à la <xref linkend="ceph-rbd-rbdmap"/>.
   </para>
  </tip>
 </sect1>
 <sect1 xml:id="cha-ceph-snapshots-rbd">
  <title>Instantanés de périphériques de traitement par blocs</title>

  <para>
   Un instantané RBD est un instantané d'une image de périphérique de traitement par blocs RADOS. Avec les instantanés, vous conservez l'historique de l'état de l'image. Ceph prend également en charge la superposition d'instantanés, ce qui vous permet de cloner des images de machine virtuelle rapidement et facilement. Ceph prend en charge les instantanés de périphériques de traitement par blocs en utilisant la commande <command>rbd</command> et de nombreuses interfaces de niveau supérieur, notamment QEMU, <systemitem>libvirt</systemitem>, OpenStack et CloudStack.
  </para>

  <note>
   <para>
    Arrêtez les opérations d'entrée et de sortie avant de capturer une image. Si l'image contient un système de fichiers, celui-ci doit être cohérent <emphasis>avant</emphasis> la capture de l'instantané.
   </para>
  </note>

  <sect2>
   <title>Remarques sur Cephx</title>
   <para>
    Quand <systemitem>cephx</systemitem> est activé (reportez-vous à la page <link xlink:href="http://ceph.com/docs/master/rados/configuration/auth-config-ref/"/> pour plus d'informations), vous devez spécifier un nom ou un ID d'utilisateur et un chemin d'accès au trousseau de clés contenant la clé correspondante pour l'utilisateur. Reportez-vous à la page <link xlink:href="http://ceph.com/docs/master/rados/operations/user-management/">Gestion des utilisateurs</link> pour plus de détails. Vous pouvez également ajouter la variable d'environnement <systemitem>CEPH_ARGS</systemitem> pour ne pas avoir à saisir à nouveau les paramètres suivants.
   </para>
<screen><prompt>root # </prompt>rbd --id <replaceable>user-ID</replaceable> --keyring=/path/to/secret <replaceable>commands</replaceable>
<prompt>root # </prompt>rbd --name <replaceable>username</replaceable> --keyring=/path/to/secret <replaceable>commands</replaceable></screen>
   <para>
    Par exemple :
   </para>
<screen><prompt>root # </prompt>rbd --id admin --keyring=/etc/ceph/ceph.keyring <replaceable>commands</replaceable>
<prompt>root # </prompt>rbd --name client.admin --keyring=/etc/ceph/ceph.keyring <replaceable>commands</replaceable></screen>
   <tip>
    <para>
     Ajoutez l'utilisateur et le secret à la variable d'environnement <systemitem>CEPH_ARGS</systemitem> afin de ne pas avoir à les saisir à chaque fois.
    </para>
   </tip>
  </sect2>

  <sect2>
   <title>Notions de base sur les instantanés</title>
   <para>
    Les procédures suivantes montrent comment créer, répertorier et supprimer des instantanés à l'aide de la commande <command>rbd</command> sur la ligne de commande.
   </para>
   <sect3>
    <title>Création d'instantanés</title>
    <para>
     Pour créer un instantané avec <command>rbd</command>, indiquez l'option <option>snap create</option>, le nom de la réserve et le nom de l'image.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> snap create --snap <replaceable>snap-name</replaceable> <replaceable>image-name</replaceable>
<prompt>root # </prompt>rbd snap create <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable>@<replaceable>snap-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool rbd snap create --snap snapshot1 image1
<prompt>root # </prompt>rbd snap create rbd/image1@snapshot1</screen>
   </sect3>
   <sect3>
    <title>Liste des instantanés</title>
    <para>
     Pour répertorier les instantanés d'une image, spécifiez le nom de la réserve et le nom de l'image.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> snap ls <replaceable>image-name</replaceable>
<prompt>root # </prompt>rbd snap ls <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool rbd snap ls image1
<prompt>root # </prompt>rbd snap ls rbd/image1</screen>
   </sect3>
   <sect3>
    <title>Retour d'un instantané à l'état initial</title>
    <para>
     Pour rétablir l'état initial d'un instantané avec <command>rbd</command>, indiquez l'option <option>snap rollback</option>, le nom de la réserve, le nom de l'image et le nom de l'instantané.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> snap rollback --snap <replaceable>snap-name</replaceable> <replaceable>image-name</replaceable>
<prompt>root # </prompt>rbd snap rollback <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable>@<replaceable>snap-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool pool1 snap rollback --snap snapshot1 image1
<prompt>root # </prompt>rbd snap rollback pool1/image1@snapshot1</screen>
    <note>
     <para>
      Le retour à l'état initial d'une image dans un instantané revient à écraser la version actuelle de l'image avec les données d'un instantané. Le temps nécessaire à l'exécution d'un retour à l'état initial augmente avec la taille de l'image. Il est <emphasis>plus rapide de cloner</emphasis> à partir d'un instantané <emphasis>que de rétablir</emphasis> une image vers un instantané, cette méthode étant recommandée pour revenir à un état préexistant.
     </para>
    </note>
   </sect3>
   <sect3>
    <title>Suppression d'un instantané</title>
    <para>
     Pour supprimer un instantané avec <command>rbd</command>, indiquez l'option <option>snap rm</option>, le nom de la réserve, le nom de l'image et le nom de l'utilisateur.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> snap rm --snap <replaceable>snap-name</replaceable> <replaceable>image-name</replaceable>
<prompt>root # </prompt>rbd snap rm <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable>@<replaceable>snap-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool pool1 snap rm --snap snapshot1 image1
<prompt>root # </prompt>rbd snap rm pool1/image1@snapshot1</screen>
    <note>
     <para>
      Les instances Ceph OSD suppriment les données de manière asynchrone de sorte que la suppression d'un instantané ne libère pas immédiatement l'espace disque.
     </para>
    </note>
   </sect3>
   <sect3>
    <title>Purge d'instantanés</title>
    <para>
     Pour supprimer tous les instantanés d'une image avec <command>rbd</command>, indiquez l'option <option>snap purge</option> et le nom de l'image.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> snap purge <replaceable>image-name</replaceable>
<prompt>root # </prompt>rbd snap purge <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool pool1 snap purge image1
<prompt>root # </prompt>rbd snap purge pool1/image1</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-snapshoti-layering">
   <title>Création de couches</title>
   <para>
    Ceph prend en charge la possibilité de créer de nombreux clones de copie à l'écriture (COW) d'un instantané de périphérique de traitements par bloc. La création de couches d'instantanés donne aux clients de périphériques de traitement par blocs Ceph les moyens de créer des images très rapidement. Par exemple, vous pouvez créer une image de périphérique de traitement par blocs avec une machine virtuelle Linux écrite, puis capturer l'image, protéger l'instantané et créer autant de clones COW que vous le souhaitez. Un instantané étant en lecture seule, le clonage d'un instantané simplifie la sémantique et permet de créer rapidement des clones.
   </para>
   <note>
    <para>
     Dans les exemples de ligne de commande ci-dessous, les termes « parent » et « child » (enfant) désignent un instantané de périphérique de traitement par blocs Ceph (parent) et l'image correspondante clonée à partir de l'instantané (enfant).
    </para>
   </note>
   <para>
    Chaque image clonée (enfant) stocke une référence à son image parent, ce qui permet à l'image clonée d'ouvrir l'instantané parent et de le lire.
   </para>
   <para>
    Un clone COW d'un instantané se comporte exactement comme n'importe quelle autre image de périphérique Ceph. Vous pouvez lire, écrire, cloner et redimensionner des images clonées. Il n'y a pas de restrictions spéciales avec les images clonées. Cependant, le clone copy-on-write d'un instantané fait référence à l'instantané, donc vous <emphasis>devez</emphasis> protéger l'instantané avant de le cloner.
   </para>
   <note>
    <para>
     Ceph prend uniquement en charge le clonage pour les images <emphasis>format 2</emphasis> (créées avec <command>rbd create --image-format 2</command>).
    </para>
   </note>
   <sect3>
    <title>Démarrage de la création de couches</title>
    <para>
     La création de couches de périphériques de traitement par blocs Ceph est un processus simple. Vous devez disposer d'une image. Vous devez créer un instantané de l'image. Vous devez protéger l'instantané. Après avoir effectué ces étapes, vous pouvez commencer le clonage de l'instantané.
    </para>
    <para>
     L'image clonée contient une référence à l'instantané parent et inclut l'ID de la réserve, l'ID de l'image et l'ID de l'instantané. L'inclusion de l'ID de réserve signifie que vous pouvez cloner des instantanés d'une réserve vers des images d'une autre réserve.
    </para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>
       <emphasis>Modèle d'image</emphasis> : un cas d'utilisation courant de la superposition de périphériques de traitement par blocs consiste à créer une image principale et un instantané servant de modèle aux clones. Par exemple, un utilisateur peut créer une image pour une distribution Linux (par exemple, SUSE Linux Enterprise Server (SLES)) et créer un instantané correspondant. Périodiquement, l'utilisateur peut mettre à jour l'image et créer un instantané (par exemple, <command>zypper ref &amp;&amp; zypper patch</command> suivi de <command>rbd snap create</command>). Au fur et à mesure que l'image mûrit, l'utilisateur peut cloner l'un des instantanés.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>Modèle étendu</emphasis> : un cas d'utilisation plus avancée inclut l'extension d'une image modèle fournissant plus d'informations qu'une image de base. Par exemple, un utilisateur peut cloner une image (un modèle de machine virtuelle) et installer d'autres logiciels (par exemple, une base de données, un système de gestion de contenu ou un système d'analyse), puis prendre un instantané de l'image agrandie, qui peut elle-même être mise à jour de la même manière que l'image de base.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>Réserve de modèles</emphasis> : une façon d'utiliser la superposition de périphériques de traitement par blocs consiste à créer une réserve contenant des images principales agissant comme des modèles et des instantanés de ces modèles. Vous pouvez ensuite étendre les privilèges de lecture seule aux utilisateurs afin qu'ils puissent cloner les instantanés sans possibilité d'écriture ou d'exécution dans la réserve.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>Migration/récupération d'image</emphasis> : une façon d'utiliser la superposition de périphériques de traitement par blocs consiste à migrer ou récupérer des données d'une réserve vers une autre.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3>
    <title>Protection d'un instantané</title>
    <para>
     Les clones accèdent aux instantanés parents. Tous les clones seraient endommagés si un utilisateur supprimait par inadvertance l'instantané parent. Pour éviter toute perte de données, vous devez protéger l'instantané avant de pouvoir le cloner.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> snap protect \
 --image <replaceable>image-name</replaceable> --snap <replaceable>snapshot-name</replaceable>
<prompt>root # </prompt>rbd snap protect <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable>@<replaceable>snapshot-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool pool1 snap protect --image image1 --snap snapshot1
<prompt>root # </prompt>rbd snap protect pool1/image1@snapshot1</screen>
    <note>
     <para>
      Vous ne pouvez pas supprimer un instantané protégé.
     </para>
    </note>
   </sect3>
   <sect3>
    <title>Clonage d'un instantané</title>
    <para>
     Pour cloner un instantané, vous devez spécifier la réserve parent, l'image, l'instantané, la réserve enfant et le nom de l'image. Vous devez protéger l'instantané avant de pouvoir le cloner.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> --image <replaceable>parent-image</replaceable> \
 --snap <replaceable>snap-name</replaceable> --dest-pool <replaceable>pool-name</replaceable> \
 --dest <replaceable>child-image</replaceable>
<prompt>root # </prompt>rbd clone <replaceable>pool-name</replaceable>/<replaceable>parent-image</replaceable>@<replaceable>snap-name</replaceable> \
<replaceable>pool-name</replaceable>/<replaceable>child-image-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd clone pool1/image1@snapshot1 pool1/image2</screen>
    <note>
     <para>
      Vous pouvez cloner un instantané d'une réserve vers une image d'une autre réserve. Par exemple, vous pouvez gérer des images en lecture seule et des instantanés en tant que modèles dans une réserve, d'une part, et des clones inscriptibles dans une autre réserve, d'autre part.
     </para>
    </note>
   </sect3>
   <sect3>
    <title>Suppression de la protection un instantané</title>
    <para>
     Avant de pouvoir supprimer un instantané, vous devez d'abord le déprotéger. En outre, vous pouvez <emphasis>ne pas</emphasis> supprimer des instantanés contenant des références de clones. Vous devez fusionner chaque clone d'un instantané avant de pouvoir supprimer celui-ci.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> snap unprotect --image <replaceable>image-name</replaceable> \
 --snap <replaceable>snapshot-name</replaceable>
<prompt>root # </prompt>rbd snap unprotect <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable>@<replaceable>snapshot-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool pool1 snap unprotect --image image1 --snap snapshot1
<prompt>root # </prompt>rbd snap unprotect pool1/image1@snapshot1</screen>
   </sect3>
   <sect3>
    <title>Liste des enfants d'un instantané</title>
    <para>
     Pour dresser la liste des enfants d'un instantané, exécutez :
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> children --image <replaceable>image-name</replaceable> --snap <replaceable>snap-name</replaceable>
<prompt>root # </prompt>rbd children <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable>@<replaceable>snapshot-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool pool1 children --image image1 --snap snapshot1
<prompt>root # </prompt>rbd children pool1/image1@snapshot1</screen>
   </sect3>
   <sect3>
    <title>Mise à plat d'une image clonée</title>
    <para>
     Les images clonées conservent une référence à l'instantané parent. Lorsque vous supprimez la référence du clone enfant dans l'instantané parent, vous « aplatissez » (fusionnez) l'image en copiant les informations de l'instantané sur le clone. Le temps nécessaire à la fusion d'un clone augmente avec la taille de l'instantané. Pour supprimer un instantané, vous devez d'abord fusionner les images enfant.
    </para>
<screen><prompt>root # </prompt>rbd --pool <replaceable>pool-name</replaceable> flatten --image <replaceable>image-name</replaceable>
<prompt>root # </prompt>rbd flatten <replaceable>pool-name</replaceable>/<replaceable>image-name</replaceable></screen>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --pool pool1 flatten --image image1
<prompt>root # </prompt>rbd flatten pool1/image1</screen>
    <note>
     <para>
      Comme une image fusionnée contient toutes les informations de l'instantané, elle occupe plus d'espace de stockage qu'un clone en couches.
     </para>
    </note>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rbd-rbdmap">
  <title>rbdmap : assignation de périphériques RBD au moment du démarrage</title>

  <para>
   <command>rbdmap</command> est un script shell qui automatise les opérations <command>rbd map</command> et <command>rbd unmap</command> sur une ou plusieurs images de périphérique de traitement par blocs RADOS. Bien que vous puissiez exécuter le script manuellement à tout moment, le cas d'utilisation le plus fréquent se compose de l'assignation et du montage automatiques des images RBD au démarrage (et du démontage et de la désassignation à l'arrêt) déclenchés par le système Init. À cet effet, un fichier unité <systemitem class="daemon">systemd</systemitem>, <filename>rbdmap.service</filename>, est fourni avec le paquetage <systemitem>ceph-common</systemitem>.
  </para>

  <para>
   Le script accepte un argument unique, qui peut être <option>map</option> ou <option>unmap</option>. Dans les deux cas, le script analyse un fichier de configuration. Il pointe vers <filename>/etc/ceph/rbdmap</filename> par défaut, mais peut être remplacé par le biais d'une variable d'environnement <literal>RBDMAPFILE</literal>. Chaque ligne du fichier de configuration correspond à une image RBD qui doit être assignée ou dont l'assignation doit être annulée.
  </para>

  <para>
   Le fichier de configuration possède le format suivant :
  </para>

<screen>image_specification rbd_options</screen>

  <variablelist>
   <varlistentry>
    <term>image_specification</term>
    <listitem>
     <para>
      Chemin d'accès à une image dans une réserve. Indiquez-le en tant que <replaceable>nom_réserve</replaceable>/<replaceable>nom_image</replaceable>. Si vous omettez <replaceable>nom_réserve</replaceable>, « rbd » est utilisé par défaut.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>rbd_options</term>
    <listitem>
     <para>
      Liste facultative de paramètres à transmettre à la commande <command>rbd map</command> sous-jacente. Ces paramètres et leurs valeurs doivent être indiqués en tant que chaîne séparée par des virgules, par exemple :
     </para>
<screen>PARAM1=VAL1,PARAM2=VAL2,...</screen>
     <para>
      Dans cet exemple suivant, le script <command>rbdmap</command> exécute la commande suivante :
     </para>
<screen>rbd map <replaceable>pool_name</replaceable>/<replaceable>image_name</replaceable> --PARAM1 VAL1 --PARAM2 VAL2</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Lorsqu'il est exécuté en tant que <command>rdbmap map</command>, le script analyse le fichier de configuration et, pour chaque image RBD indiquée, tente d'abord d'assigner l'image (en utilisant la commande <command>rbd map</command>), puis de la monter.
  </para>

  <para>
   Lorsqu'elles sont exécutées en tant que <command>rbdmap unmap</command>, les images répertoriées dans le fichier de configuration seront démontées et désassignées.
  </para>

  <para>
   <command>rbdmap unmap-all</command> tente de démonter puis de désassigner toutes les images RBD actuellement assignées, qu'elles soient ou non répertoriées dans le fichier de configuration.
  </para>

  <para>
   En cas de réussite, l'opération d'assignation rbd assigne l'image à un périphérique /dev/rbdX ; une règle udev est déclenchée afin de créer un lien symbolique de nom de périphérique convivial <filename>/dev/rbd/<replaceable>nom_réserve</replaceable>/<replaceable>nom_image</replaceable></filename> pointant vers le périphérique assigné réel.
  </para>

  <para>
   Pour que le montage et le démontage réussissent, le nom de périphérique « convivial » doit être répertorié dans le fichier <filename>/etc/fstab</filename>. Lors de l'écriture d'entrées <filename>/etc/fstab</filename> pour les images RBD, indiquez l'option de montage « noauto » (ou « nofail »). Cela empêche le système Init d'essayer de monter le périphérique trop tôt, avant même que le périphérique en question existe, car <filename>rbdmap.service</filename> est généralement déclenché assez tard dans la séquence de démarrage.
  </para>

  <para>
   Pour obtenir la liste complète des options de <command>rbd</command>, reportez-vous à la page de manuel <command>rbd</command> (<command>man 8 rbd</command>).
  </para>

  <para>
   Pour obtenir des exemples de l'utilisation de <command>rbd</command>, reportez-vous à la page de manuel de <command>rbd</command> (<command>man 8 rbd</command>).
  </para>
 </sect1>
 <sect1 xml:id="ceph-rbd-mirror">
  <title>Mise en miroir des périphériques de traitement par blocs RADOS</title>

  <para>
   Les images RBD peuvent être mises en miroir de manière asynchrone entre deux grappes Ceph. Cette fonction utilise la fonctionnalité d'image de journalisation RBD afin de garantir une réplication cohérente entre grappes en cas de panne. La mise en miroir est configurée réserve par réserve au sein des grappes homologues et peut être configurée pour refléter automatiquement toutes les images d'une réserve ou uniquement un sous-ensemble spécifique d'images. La mise en miroir est configurée à l'aide de la commande <command>rbd</command>. Le daemon <systemitem>rbd-mirror</systemitem> est chargé d'extraire les mises à jour de l'image de la grappe homologue distante et de les appliquer à l'image dans la grappe locale.
  </para>

  <important>
   <title>daemon rbd-mirror</title>
   <para>
    Pour utiliser la mise en miroir RBD, vous devez disposer de deux grappes Ceph, exécutant chacune le daemon <systemitem>rbd-mirror</systemitem>.
   </para>
  </important>

  <sect2 xml:id="rbd-mirror-daemon">
   <title>daemon rbd-mirror</title>
   <para>
    Les deux daemons <systemitem>rbd-mirror</systemitem> sont chargés d'examiner les journaux d'images sur la grappe distante homologue et de relire les événements du journal sur la grappe locale. La fonction de journalisation d'image RBD enregistre toutes les modifications apportées à l'image dans l'ordre où elles se produisent. Cela garantit qu'un miroir cohérent de l'image distante est disponible localement.
   </para>
   <para>
    Le daemon <systemitem>rbd-mirror</systemitem> est disponible dans le package <systemitem>rbd-mirror</systemitem>. Installez, activez et démarrez-le sur l'un des noeuds de la grappe :
   </para>
<screen><prompt>root@minion &gt; </prompt>zypper install rbd-mirror
<prompt>root@minion &gt; </prompt>systemctl enable ceph-rbd-mirror@<replaceable>server_name</replaceable>.service
<prompt>root@minion &gt; </prompt>systemctl start ceph-rbd-mirror@<replaceable>server_name</replaceable>.service</screen>
   <important>
    <para>
     Chaque daemon <systemitem>rbd-mirror</systemitem> doit pouvoir de se connecter aux deux grappes simultanément.
    </para>
   </important>
  </sect2>

  <sect2 xml:id="ceph-rbd-mirror-poolconfig">
   <title>Configuration de la réserve</title>
   <para>
    Les procédures suivantes montrent comment effectuer les tâches d'administration de base pour configurer la mise en miroir à l'aide de la commande <command>rbd</command>. La mise en miroir est configurée réserve par réserve au sein des grappes Ceph.
   </para>
   <para>
    Vous devez effectuer les étapes de configuration de la réserve sur les deux grappes homologues. Ces procédures supposent que deux grappes, nommées « local » et « remote », sont accessibles depuis un seul hôte pour plus de clarté.
   </para>
   <para>
    Reportez-vous à la page de manuel <command>rbd</command> (<command>man 8 rbd</command>) pour plus de détails sur la procédure de connexion à des grappes Ceph différentes.
   </para>
   <tip>
    <title>grappes multiples</title>
    <para>
     Dans les exemples suivants, le nom de la grappe correspond à un fichier de configuration Ceph du même nom <filename>/etc/ceph/remote.conf</filename>. Reportez-vous à la documentation de <link xlink:href="http://docs.ceph.com/docs/master/rados/configuration/ceph-conf/#running-multiple-clusters">ceph-conf</link> pour savoir comment configurer plusieurs grappes.
    </para>
   </tip>
   <sect3>
    <title>Activation de la mise en miroir</title>
    <para>
     Pour activer la mise en miroir sur une grappe, indiquez la sous-commande <command>mirror pool enable</command>, le nom de la réserve et le mode de mise en miroir. Le mode de mise en miroir peut être pool ou image :
    </para>
    <variablelist>
     <varlistentry>
      <term>pool</term>
      <listitem>
       <para>
        Toutes les images de la réserve dont la fonctionnalité de journalisation est activée sont mises en miroir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>image</term>
      <listitem>
       <para>
        La mise en miroir doit être explicitement activée sur chaque image. Pour plus d'informations, reportez-vous à la <xref linkend="rbd-mirror-enable-image-mirroring"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Par exemple :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror pool enable image-pool pool
<prompt>root # </prompt>rbd --cluster remote mirror pool enable image-pool pool</screen>
   </sect3>
   <sect3>
    <title>Désactivation de la mise en miroir</title>
    <para>
     Pour désactiver la mise en miroir sur une grappe, indiquez la sous-commande <command>mirror pool disable</command> et le nom de la réserve. Lorsque la mise en miroir est désactivée sur une réserve de cette manière, la mise en miroir est également désactivée sur toutes les images (dans la réserve) pour lesquelles la mise en miroir a été explicitement activée.
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror pool disable image-pool
<prompt>root # </prompt>rbd --cluster remote mirror pool disable image-pool</screen>
   </sect3>
   <sect3>
    <title>Ajout d'un homologue de grappe</title>
    <para>
     Pour que le daemon <systemitem>rbd-mirror</systemitem> découvre sa grappe homologue, l'homologue doit être enregistré dans la réserve. Pour ajouter une grappe homologue de mise en miroir, indiquez la sous-commande <command>mirror pool peer add</command>, le nom de la réserve et une spécification de grappe :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror pool peer add image-pool client.remote@remote
<prompt>root # </prompt>rbd --cluster remote mirror pool peer add image-pool client.local@local</screen>
   </sect3>
   <sect3>
    <title>Suppression d'un homologue de grappe</title>
    <para>
     Pour supprimer une grappe homologue de mise en miroir, indiquez la sous-commande <command>mirror pool peer remove</command>, le nom de la réserve et l'UUID de l'homologue (disponible dans le résultat de la commande <command>rbd mirror pool info</command>) :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror pool peer remove image-pool \
 55672766-c02b-4729-8567-f13a66893445
<prompt>root # </prompt>rbd --cluster remote mirror pool peer remove image-pool \
 60c0e299-b38f-4234-91f6-eed0a367be08</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="rbd-mirror-imageconfig">
   <title>Configuration d'image</title>
   <para>
    Contrairement à la configuration de réserve, la configuration d'image ne doit être effectuée que par rapport à une seule grappe Ceph homologue de mise en miroir.
   </para>
   <para>
    Les images RBD en miroir sont désignées comme étant soit <emphasis>primaires</emphasis>, soit <emphasis>non primaires</emphasis>. Il s'agit d'une propriété de l'image et non pas de la réserve. Les images qui sont désignées comme non primaires ne sont pas modifiables.
   </para>
   <para>
    Les images sont automatiquement promues au rang d'images primaires lorsque la mise en miroir est activée pour la première fois sur une image (soit implicitement si le mode de mise en miroir de la réserve était « pool » et que la fonctionnalité de journalisation de l'image a été activée, soit explicitement à l'aide de la commande <command>rbd</command> (reportez-vous à la <xref linkend="rbd-mirror-enable-image-mirroring"/>).
   </para>
   <sect3>
    <title>Activation de la prise en charge de la journalisation d'images</title>
    <para>
     La mise en miroir RBD utilise la fonctionnalité de journalisation RBD pour garantir que l'image répliquée est préservée en cas de panne. Avant qu'une image puisse être mise en miroir sur une grappe homologue, la fonctionnalité de journalisation doit être activée. La fonctionnalité peut être activée au moment de la création d'image en fournissant l'option <option>--image-feature exclusive-lock,journaling</option> à la commande <command>rbd</command>.
    </para>
    <para>
     Le cas échéant, la fonction de journalisation peut être dynamiquement activée sur des images RBD préexistantes. Pour activer la journalisation, indiquez la sous-commande <command>feature enable</command>, le nom de la réserve et de l'image, et le nom de l'entité :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local feature enable image-pool/image-1 journaling</screen>
    <note>
     <title>dépendance d'options</title>
     <para>
      La fonctionnalité <option>journaling</option> dépend de la fonctionnalité<option>exclusive-lock</option>. Si la fonctionnalité <option>exclusive-lock</option> n'est pas encore activée, vous devez l'activer avant la fonctionnalité <option>journaling</option>.
     </para>
    </note>
    <tip>
     <title>journalisation sur toutes les nouvelles images</title>
     <para>
      Vous pouvez activer la journalisation sur toutes les nouvelles images par défaut en ajoutant la ligne suivante à votre fichier de configuration de Ceph :
     </para>
<screen>rbd default features = 125</screen>
    </tip>
   </sect3>
   <sect3 xml:id="rbd-mirror-enable-image-mirroring">
    <title>Activation de la mise en miroir d'image</title>
    <para>
     Si la mise en miroir est configurée en mode « image » pour la réserve de l'image, il est nécessaire d'activer explicitement la mise en miroir pour chaque image de la réserve. Pour activer la mise en miroir d'une image en particulier, indiquez la sous-commande <command>mirror image enable</command> avec le nom de la réserve et le nom de l'image :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror image enable image-pool/image-1</screen>
   </sect3>
   <sect3>
    <title>Désactivation de la mise en miroir d'image</title>
    <para>
     Pour désactiver la mise en miroir d'une image en particulier, indiquez la sous-commande <command>mirror image disable</command> avec le nom de la réserve et le nom de l'image :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror image disable image-pool/image-1</screen>
   </sect3>
   <sect3>
    <title>Promotion et rétrogradation de l'image</title>
    <para>
     Dans un scénario de basculement où la désignation principale doit être déplacée sur l'image dans la grappe homologue, vous devez arrêter l'accès à l'image primaire, rétrograder l'image primaire actuelle, promouvoir la nouvelle image primaire et reprendre l'accès à l'image sur la grappe alternative.
    </para>
    <para>
     Pour rétrograder une image non primaire spécifique, indiquez la sous-commande <command>mirror image demote</command> ainsi que le nom de la réserve et le nom de l'image :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror image demote image-pool/image-1</screen>
    <para>
     Pour rétrograder toutes les images primaires, indiquez la sous-commande <command>mirror image demote</command> ainsi que le nom de la réserve :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror pool demote image-pool</screen>
    <para>
     Pour promouvoir une image spécifique au rang d'image primaire, indiquez la sous-commande <command>mirror image promote</command> ainsi que le nom de la réserve et le nom de l'image :
    </para>
<screen><prompt>root # </prompt>rbd --cluster remote mirror image promote image-pool/image-1</screen>
    <para>
     Pour promouvoir toutes les images non primaires d'une réserve au rang d'images primaires, indiquez la sous-commande <command>mirror image promote</command> ainsi que le nom de la réserve :
    </para>
<screen><prompt>root # </prompt>rbd --cluster local mirror pool promote image-pool</screen>
    <tip>
     <title>division de la charge d'E/S</title>
     <para>
      Comme l'état primaire ou non primaire s'applique au niveau de l'image, il est possible que deux grappes divisent le chargement des E/S et le basculement ou la restauration par phases.
     </para>
    </tip>
    <note>
     <title>promotion forcée</title>
     <para>
      La promotion peut être forcée à l'aide de l'option <option>--force</option>. La promotion forcée est nécessaire lorsque la rétrogradation ne peut pas être propagée à la grappe homologue (par exemple, en cas d'échec de la grappe ou de panne de communication). Cela se traduira par un scénario de divergence entre les deux homologues, et l'image ne sera plus synchronisée jusqu'à l'émission de la sous-commande <command>resync</command>.
     </para>
    </note>
   </sect3>
   <sect3>
    <title>Forcer la resynchronisation de l'image</title>
    <para>
     Si le daemon <systemitem>rbd-mirror</systemitem> détecte un événement de divergence, il n'y aura pas de tentative de mettre en miroir l'image concernée jusqu'à ce que celle-ci soit corrigée. Pour reprendre la mise en miroir d'une image, commencez par rétrograder l'image jugée obsolète, puis demandez une resynchronisation avec l'image principale. Pour demander une resynchronisation de l'image, indiquez la sous-commande <command>mirror image resync</command> avec le nom de la réserve et le nom de l'image :
    </para>
<screen><prompt>root # </prompt>rbd mirror image resync image-pool/image-1</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="rbd-mirror-status">
   <title>État miroir</title>
   <para>
    L'état de réplication de la grappe homologue est stocké pour chaque image en miroir principale. Cet état peut être récupéré à l'aide des sous-commandes <command>mirror image status</command> et <command>mirror pool status</command> :
   </para>
   <para>
    Pour demander l'état de l'image miroir, indiquez la sous-commande <command>mirror image status</command> avec le nom de la réserve et le nom de l'image :
   </para>
<screen><prompt>root # </prompt>rbd mirror image status image-pool/image-1</screen>
   <para>
    Pour demander l'état du résumé de la réserve miroir, indiquez la sous-commande <command>mirror pool status</command> avec le nom de la réserve :
   </para>
<screen><prompt>root # </prompt>rbd mirror pool status image-pool</screen>
   <tip>
    <title/>
    <para>
     L'option <option>--verbose</option> de la sous-commande <command>mirror pool status</command> permet d'afficher des informations détaillées sur l'état de chaque image de mise en miroir présente dans la réserve.
    </para>
   </tip>
  </sect2>
 </sect1>
</chapter>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="admin-caasp-crd">
  <!-- ============================================================== -->
  <title>&ceph; Cluster Custom Resource Definitions</title>
  <remark>
    Section 1 - Content from: https://rook.io/docs/rook/v1.4/ceph-cluster-crd.html
    Ignore "Ceph container images" section

    Sect 2 - Content from: https://rook.io/docs/rook/v1.4/ceph-pool-crd.html

    Sect 3 - Content from: https://rook.io/docs/rook/v1.4/ceph-filesystem-crd.html
  </remark>

  <section xml:id="rook-ceph-cluster-crd">
  <title>Ceph Cluster CRD</title>
  <para>
    Rook allows creation and customization of storage clusters through
    the custom resource definitions (CRDs). There are two different
    modes to create your cluster, depending on whether storage can be
    dynamically provisioned on which to base the Ceph cluster.
  </para>
  <orderedlist numeration="arabic" spacing="compact">
    <listitem>
      <para>
        Specify host paths and raw devices
      </para>
    </listitem>
    <listitem>
      <para>
        Specify the storage class Rook should use to consume storage via
        PVCs
      </para>
    </listitem>
  </orderedlist>
  <para>
    Following is an example for each of these approaches.
  </para>
  <section xml:id="rook-host-based-cluster">
    <title>Host-based Cluster</title>
    <para>
      To get you started, here is a simple example of a CRD to configure
      a Ceph cluster with all nodes and all devices. Next example is
      where Mons and OSDs are backed by PVCs. More examples are included
      <link linkend="rook-samples">later in this doc</link>.
    </para>
    <blockquote>
      <para>
        <emphasis role="strong">NOTE</emphasis>: In addition to your
        CephCluster object, you need to create the namespace, service
        accounts, and RBAC rules for the namespace you are going to
        create the CephCluster in. These resources are defined in the
        example <literal>common.yaml</literal>.
      </para>
    </blockquote>
    <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    # see the &quot;Cluster Settings&quot; section below for more details on which image of ceph to run
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  storage:
    useAllNodes: true
    useAllDevices: true
</programlisting>
  </section>
  <section xml:id="rook-pvc-based-cluster">
    <title>PVC-based Cluster</title>
    <blockquote>
      <para>
        <emphasis role="strong">NOTE</emphasis>: Kubernetes version
        1.13.0 or greater is required to provision OSDs on PVCs.
      </para>
    </blockquote>
    <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    # see the &quot;Cluster Settings&quot; section below for more details on which image of ceph to run
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    volumeClaimTemplate:
      spec:
        storageClassName: local-storage
        resources:
          requests:
            storage: 10Gi
  storage:
   storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      encrypted: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: local-storage
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</programlisting>
    <para>
      For a more advanced scenario, such as adding a dedicated device
      you can refer to the
      <link linkend="rook-dedicated-metadata-and-wal-device-for-osd-on-pvc">dedicated
      metadata device for OSD on PVC section</link>.
    </para>
  </section>
  <section xml:id="rook-settings">
    <title>Settings</title>
    <para>
      Settings can be specified at the global level to apply to the
      cluster as a whole, while other settings can be specified at more
      fine-grained levels. If any setting is unspecified, a suitable
      default will be used automatically.
    </para>
    <section xml:id="rook-cluster-metadata">
      <title>Cluster metadata</title>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>name</literal>: The name that will be used
            internally for the Ceph cluster. Most commonly the name is
            the same as the namespace since multiple clusters are not
            supported in the same namespace.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>namespace</literal>: The Kubernetes namespace that
            will be created for the Rook cluster. The services, pods,
            and other resources created by the operator will be added to
            this namespace. The common scenario is to create a single
            Rook cluster. If multiple clusters are created, they must
            not have conflicting devices or host paths.
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-cluster-settings">
      <title>Cluster Settings</title>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>external</literal>:
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>enable</literal>: if <literal>true</literal>,
                the cluster will not be managed by Rook but via an
                external entity. This mode is intended to connect to an
                existing cluster. In this case, Rook will only consume
                the external cluster. However, Rook will be able to
                deploy various daemons in Kubernetes such as object
                gateways, mds and nfs if an image is provided and will
                refuse otherwise. If this setting is enabled
                <emphasis role="strong">all</emphasis> the other options
                will be ignored except
                <literal>cephVersion.image</literal> and
                <literal>dataDirHostPath</literal>. See
                <link linkend="rook-external-cluster">external cluster
                configuration</link>. If
                <literal>cephVersion.image</literal> is left blank, Rook
                will refuse the creation of extra CRs like object, file
                and nfs.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>cephVersion</literal>: The version information for
            launching the ceph daemons.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>image</literal>: The image used for running the
                ceph daemons. For example,
                <literal>ceph/ceph:v14.2.10</literal> or
                <literal>ceph/ceph:v15.2.4</literal>. For more details
                read the <link linkend="rook-ceph-container-images">container
                images section</link>. For the latest ceph images, see
                the
                <link xlink:href="https://hub.docker.com/r/ceph/ceph/tags/">Ceph
                DockerHub</link>. To ensure a consistent version of the
                image is running across all nodes in the cluster, it is
                recommended to use a very specific image version. Tags
                also exist that would give the latest version, but they
                are only recommended for test environments. For example,
                the tag <literal>v14</literal> will be updated each time
                a new nautilus build is released. Using the
                <literal>v14</literal> or similar tag is not recommended
                in production because it may lead to inconsistent
                versions of the image running across different nodes in
                the cluster.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>allowUnsupported</literal>: If
                <literal>true</literal>, allow an unsupported major
                version of the Ceph release. Currently
                <literal>nautilus</literal> and
                <literal>octopus</literal> are supported. Future
                versions such as <literal>pacific</literal> would
                require this to be set to <literal>true</literal>.
                Should be set to <literal>false</literal> in production.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>dataDirHostPath</literal>: The path on the host
            (<link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#hostpath">hostPath</link>)
            where config and data should be stored for each of the
            services. If the directory does not exist, it will be
            created. Because this directory persists on the host, it
            will remain after pods are deleted. Following paths and any
            of their subpaths <emphasis role="strong">must not be
            used</emphasis>: <literal>/etc/ceph</literal>,
            <literal>/rook</literal> or
            <literal>/var/log/ceph</literal>.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                On <emphasis role="strong">Minikube</emphasis>
                environments, use <literal>/data/rook</literal>.
                Minikube boots into a tmpfs but it provides some
                <link xlink:href="https://github.com/kubernetes/minikube/blob/master/site/content/en/docs/handbook/persistent_volumes.md#a-note-on-mounts-persistence-and-minikube-hosts">directories</link>
                where files can be persisted across reboots. Using one
                of these directories will ensure that Rook’s data and
                configuration files are persisted and that enough
                storage space is available.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="strong">WARNING</emphasis>: For test
                scenarios, if you delete a cluster and start a new
                cluster on the same hosts, the path used by
                <literal>dataDirHostPath</literal> must be deleted.
                Otherwise, stale keys and other config will remain from
                the previous cluster and the new mons will fail to
                start. If this value is empty, each pod will get an
                ephemeral directory to store their config files that is
                tied to the lifetime of the pod running on that node.
                More details can be found in the Kubernetes
                <link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir">empty
                dir docs</link>.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>skipUpgradeChecks</literal>: if set to true Rook
            won’t perform any upgrade checks on Ceph daemons during an
            upgrade. Use this at <emphasis role="strong">YOUR OWN
            RISK</emphasis>, only if you know what you’re doing. To
            understand Rook’s upgrade process of Ceph, read the
            <link xlink:href="ceph-upgrade.md#ceph-version-upgrades">upgrade
            doc</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>continueUpgradeAfterChecksEvenIfNotHealthy</literal>:
            if set to true Rook will continue the OSD daemon upgrade
            process even if the PGs are not clean, or continue with the
            MDS upgrade even the file system is not healthy.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>dashboard</literal>: Settings for the Ceph
            dashboard. To view the dashboard in your browser see the
            <link xlink:href="ceph-dashboard.md">dashboard guide</link>.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>enabled</literal>: Whether to enable the
                dashboard to view cluster status
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>urlPrefix</literal>: Allows to serve the
                dashboard under a subpath (useful when you are accessing
                the dashboard via a reverse proxy)
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>port</literal>: Allows to change the default
                port where the dashboard is served
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>ssl</literal>: Whether to serve the dashboard
                via SSL, ignored on Ceph versions older than
                <literal>13.2.2</literal>
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>monitoring</literal>: Settings for monitoring Ceph
            using Prometheus. To enable monitoring on your cluster see
            the
            <link xlink:href="ceph-monitoring.md#prometheus-alerts">monitoring
            guide</link>.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>enabled</literal>: Whether to enable prometheus
                based monitoring for this cluster
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>rulesNamespace</literal>: Namespace to deploy
                prometheusRule. If empty, namespace of the cluster will
                be used. Recommended:
              </para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>
                    If you have a single Rook Ceph cluster, set the
                    <literal>rulesNamespace</literal> to the same
                    namespace as the cluster or keep it empty.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    If you have multiple Rook Ceph clusters in the same
                    Kubernetes cluster, choose the same namespace to set
                    <literal>rulesNamespace</literal> for all the
                    clusters (ideally, namespace with prometheus
                    deployed). Otherwise, you will get duplicate alerts
                    with duplicate alert definitions.
                  </para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>network</literal>: For the network settings for the
            cluster, refer to the
            <link linkend="rook-network-configuration-settings">network
            configuration settings</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mon</literal>: contains mon related options
            <link linkend="rook-mon-settings">mon settings</link> For more
            details on the mons and when to choose a number other than
            <literal>3</literal>, see the
            <link xlink:href="https://github.com/rook/rook/blob/master/design/ceph/mon-health.md">mon
            health design doc</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mgr</literal>: manager top level section
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>modules</literal>: is the list of Ceph manager
                modules to enable
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>crashCollector</literal>: The settings for crash
            collector daemon(s).
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>disable</literal>: is set to
                <literal>true</literal>, the crash collector will not
                run on any node where a Ceph daemon runs
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>annotations</literal>:
            <link linkend="rook-annotations-and-labels">annotations
            configuration settings</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>labels</literal>:
            <link linkend="rook-annotations-and-labels">labels configuration
            settings</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>placement</literal>:
            <link linkend="rook-placement-configuration-settings">placement
            configuration settings</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>resources</literal>:
            <link linkend="rook-cluster-wide-resources-configuration-settings">resources
            configuration settings</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>priorityClassNames</literal>:
            <link linkend="rook-priority-class-names-configuration-settings">priority
            class names configuration settings</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>storage</literal>: Storage selection and
            configuration that will be used across the cluster. Note
            that these settings can be overridden for specific nodes.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>useAllNodes</literal>: <literal>true</literal>
                or <literal>false</literal>, indicating if all nodes in
                the cluster should be used for storage according to the
                cluster level storage selection and configuration
                values. If individual nodes are specified under the
                <literal>nodes</literal> field, then
                <literal>useAllNodes</literal> must be set to
                <literal>false</literal>.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>nodes</literal>: Names of individual nodes in
                the cluster that should have their storage included in
                accordance with either the cluster level configuration
                specified above or any node specific overrides described
                in the next section below.
                <literal>useAllNodes</literal> must be set to
                <literal>false</literal> to use specific nodes and their
                config. See <link linkend="rook-node-settings">node
                settings</link> below.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>config</literal>: Config settings applied to
                all OSDs on the node unless overridden by
                <literal>devices</literal>. See the
                <link linkend="rook-osd-configuration-settings">config
                settings</link> below.
              </para>
            </listitem>
            <listitem>
              <para>
                <link linkend="rook-storage-selection-settings">storage
                selection settings</link>
              </para>
            </listitem>
            <listitem>
              <para>
                <link linkend="rook-storage-class-device-sets">Storage Class
                Device Sets</link>
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>disruptionManagement</literal>: The section for
            configuring management of daemon disruptions
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>managePodBudgets</literal>: if
                <literal>true</literal>, the operator will create and
                manage PodDisruptionBudgets for OSD, Mon, RGW, and MDS
                daemons. OSD PDBs are managed dynamically via the
                strategy outlined in the
                <link xlink:href="https://github.com/rook/rook/blob/master/design/ceph/ceph-managed-disruptionbudgets.md">design</link>.
                The operator will block eviction of OSDs by default and
                unblock them safely when drains are detected.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>osdMaintenanceTimeout</literal>: is a duration
                in minutes that determines how long an entire
                failureDomain like <literal>region/zone/host</literal>
                will be held in <literal>noout</literal> (in addition to
                the default DOWN/OUT interval) when it is draining. This
                is only relevant when
                <literal>managePodBudgets</literal> is
                <literal>true</literal>. The default value is
                <literal>30</literal> minutes.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>manageMachineDisruptionBudgets</literal>: if
                <literal>true</literal>, the operator will create and
                manage MachineDisruptionBudgets to ensure OSDs are only
                fenced when the cluster is healthy. Only available on
                OpenShift.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>machineDisruptionBudgetNamespace</literal>: the
                namespace in which to watch the
                MachineDisruptionBudgets.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>removeOSDsIfOutAndSafeToRemove</literal>: If
            <literal>true</literal> the operator will remove the OSDs
            that are down and whose data has been restored to other
            OSDs. In Ceph terms, the osds are <literal>out</literal> and
            <literal>safe-to-destroy</literal> when then would be
            removed.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>cleanupPolicy</literal>:
            <link linkend="rook-cleanup-policy">cleanup policy
            settings</link>
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-ceph-container-images">
      <title>Ceph container images</title>
      <para>
        Official releases of Ceph Container images are available from
        <link xlink:href="https://hub.docker.com/r/ceph">Docker
        Hub</link>.
      </para>
      <para>
        These are general purpose Ceph container with all necessary
        daemons and dependencies installed.
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left" />
          <colspec align="left" />
          <thead>
            <row>
              <entry>
                TAG
              </entry>
              <entry>
                MEANING
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                vRELNUM
              </entry>
              <entry>
                Latest release in this series (e.g.,
                <emphasis>v14</emphasis> = Nautilus)
              </entry>
            </row>
            <row>
              <entry>
                vRELNUM.Y
              </entry>
              <entry>
                Latest stable release in this stable series (e.g.,
                v14.2)
              </entry>
            </row>
            <row>
              <entry>
                vRELNUM.Y.Z
              </entry>
              <entry>
                A specific release (e.g., v14.2.5)
              </entry>
            </row>
            <row>
              <entry>
                vRELNUM.Y.Z-YYYYMMDD
              </entry>
              <entry>
                A specific build (e.g., v14.2.5-20191203)
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        A specific will contain a specific release of Ceph as well as
        security fixes from the Operating System.
      </para>
    </section>
    <section xml:id="rook-mon-settings">
      <title>Mon Settings</title>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>count</literal>: Set the number of mons to be
            started. The number should be odd and between
            <literal>1</literal> and <literal>9</literal>. If not
            specified the default is set to <literal>3</literal> and
            <literal>allowMultiplePerNode</literal> is also set to
            <literal>true</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>allowMultiplePerNode</literal>: Enable
            (<literal>true</literal>) or disable
            (<literal>false</literal>) the placement of multiple mons on
            one node. Default is <literal>false</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>volumeClaimTemplate</literal>: A
            <literal>PersistentVolumeSpec</literal> used by Rook to
            create PVCs for monitor storage. This field is optional, and
            when not provided, HostPath volume mounts are used. The
            current set of fields from template that are used are
            <literal>storageClassName</literal> and the
            <literal>storage</literal> resource request and limit. The
            default storage size request for new PVCs is
            <literal>10Gi</literal>. Ensure that associated storage
            class is configured to use
            <literal>volumeBindingMode: WaitForFirstConsumer</literal>.
            This setting only applies to new monitors that are created
            when the requested number of monitors increases, or when a
            monitor fails and is recreated. An
            <link linkend="rook-using-pvc-storage-for-monitors">example CRD
            configuration is provided below</link>.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        If these settings are changed in the CRD the operator will
        update the number of mons during a periodic check of the mon
        health, which by default is every 45 seconds.
      </para>
      <para>
        To change the defaults that the operator uses to determine the
        mon health and whether to failover a mon, refer to the
        <link linkend="rook-health-settings">health settings</link>. The
        intervals should be small enough that you have confidence the
        mons will maintain quorum, while also being long enough to
        ignore network blips where mons are failed over too often.
      </para>
    </section>
    <section xml:id="rook-mgr-settings">
      <title>Mgr Settings</title>
      <para>
        You can use the cluster CR to enable or disable any manager
        module. This can be configured like so:
      </para>
      <programlisting language="yaml">
mgr:
  modules:
  - name: &lt;name of the module&gt;
    enabled: true
</programlisting>
      <para>
        Some modules will have special configuration to ensure the
        module is fully functional after being enabled. Specifically:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>pg_autoscaler</literal>: Rook will configure all
            new pools with PG autoscaling by setting:
            <literal>osd_pool_default_pg_autoscale_mode = on</literal>
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-network-configuration-settings">
      <title>Network Configuration Settings</title>
      <para>
        If not specified, the default SDN will be used. Configure the
        network that will be enabled for the cluster and services.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>provider</literal>: Specifies the network provider
            that will be used to connect the network interface. You can
            choose between <literal>host</literal>, and
            <literal>multus</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>selectors</literal>: List the network selector(s)
            that will be used associated by a key.
          </para>
        </listitem>
      </itemizedlist>
      <blockquote>
        <para>
          <emphasis role="strong">NOTE:</emphasis> Changing networking
          configuration after a Ceph cluster has been deployed is NOT
          supported and will result in a non-functioning cluster.
        </para>
      </blockquote>
      <section xml:id="rook-host-networking">
        <title>Host Networking</title>
        <para>
          To use host networking, set <literal>provider: host</literal>.
        </para>
      </section>
      <section xml:id="rook-multus-experimental">
        <title>Multus (EXPERIMENTAL)</title>
        <para>
          Rook has experimental support for Multus. Currently there is
          an
          <link xlink:href="https://github.com/ceph/ceph-csi/issues/1323">open
          issue</link> in ceph-csi which explains the csi-rbdPlugin
          issue while using multus network.
        </para>
        <para>
          The selector keys are required to be <literal>public</literal>
          and <literal>cluster</literal> where each represent:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <literal>public</literal>: client communications with the
              cluster (reads/writes)
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>cluster</literal>: internal Ceph replication
              network
            </para>
          </listitem>
        </itemizedlist>
        <para>
          If you want to learn more, please read
          <link xlink:href="https://docs.ceph.com/docs/master/rados/configuration/network-config-ref/">Ceph
          Networking reference</link>.
        </para>
        <para>
          Based on the configuration, the operator will do the
          following:
        </para>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              if only the <literal>public</literal> selector is
              specified both communication and replication will happen
              on that network
            </para>
          </listitem>
          <listitem>
            <para>
              if both <literal>public</literal> and
              <literal>cluster</literal> selectors are specified the
              first one will run the communication network and the
              second the replication network
            </para>
          </listitem>
        </orderedlist>
        <para>
          In order to work, each selector value must match a
          <literal>NetworkAttachmentDefinition</literal> object name in
          Multus. For example, you can do:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <literal>public</literal>:
              <quote>my-public-storage-network</quote>
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>cluster</literal>:
              <quote>my-replication-storage-network</quote>
            </para>
          </listitem>
        </itemizedlist>
        <para>
          For <literal>multus</literal> network provider, an already
          working cluster with Multus networking is required. Network
          attachment definition that later will be attached to the
          cluster needs to be created before the Cluster CRD. The
          Network attachment definitions should be using whereabouts
          cni. If Rook cannot find the provided Network attachment
          definition it will fail running the Ceph OSD pods. You can add
          the Multus network attachment selection annotation selecting
          the created network attachment definition on
          <literal>selectors</literal>.
        </para>
      </section>
    </section>
    <section xml:id="rook-node-settings">
      <title>Node Settings</title>
      <para>
        In addition to the cluster level settings specified above, each
        individual node can also specify configuration to override the
        cluster level settings and defaults. If a node does not specify
        any configuration then it will inherit the cluster level
        settings.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>name</literal>: The name of the node, which should
            match its <literal>kubernetes.io/hostname</literal> label.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>config</literal>: Config settings applied to all
            OSDs on the node unless overridden by
            <literal>devices</literal>. See the
            <link linkend="rook-osd-configuration-settings">config
            settings</link> below.
          </para>
        </listitem>
        <listitem>
          <para>
            <link linkend="rook-storage-selection-settings">storage selection
            settings</link>
          </para>
        </listitem>
      </itemizedlist>
      <para>
        When <literal>useAllNodes</literal> is set to
        <literal>true</literal>, Rook attempts to make Ceph cluster
        management as hands-off as possible while still maintaining
        reasonable data safety. If a usable node comes online, Rook will
        begin to use it automatically. To maintain a balance between
        hands-off usability and data safety, Nodes are removed from Ceph
        as OSD hosts only (1) if the node is deleted from Kubernetes
        itself or (2) if the node has its taints or affinities modified
        in such a way that the node is no longer usable by Rook. Any
        changes to taints or affinities, intentional or unintentional,
        may affect the data reliability of the Ceph cluster. In order to
        help protect against this somewhat, deletion of nodes by taint
        or affinity modifications must be <quote>confirmed</quote> by
        deleting the Rook-Ceph operator pod and allowing the operator
        deployment to restart the pod.
      </para>
      <para>
        For production clusters, we recommend that
        <literal>useAllNodes</literal> is set to
        <literal>false</literal> to prevent the Ceph cluster from
        suffering reduced data reliability unintentionally due to a user
        mistake. When <literal>useAllNodes</literal> is set to
        <literal>false</literal>, Rook relies on the user to be explicit
        about when nodes are added to or removed from the Ceph cluster.
        Nodes are only added to the Ceph cluster if the node is added to
        the Ceph cluster resource. Similarly, nodes are only removed if
        the node is removed from the Ceph cluster resource.
      </para>
      <section xml:id="rook-node-updates">
        <title>Node Updates</title>
        <para>
          Nodes can be added and removed over time by updating the
          Cluster CRD, for example with
          <literal>kubectl -n rook-ceph edit cephcluster rook-ceph</literal>.
          This will bring up your default text editor and allow you to
          add and remove storage nodes from the cluster. This feature is
          only available when <literal>useAllNodes</literal> has been
          set to <literal>false</literal>.
        </para>
      </section>
    </section>
    <section xml:id="rook-storage-selection-settings">
      <title>Storage Selection Settings</title>
      <para>
        Below are the settings available, both at the cluster and
        individual node level, for selecting which storage resources
        will be included in the cluster.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>useAllDevices</literal>: <literal>true</literal> or
            <literal>false</literal>, indicating whether all devices
            found on nodes in the cluster should be automatically
            consumed by OSDs. <emphasis role="strong">Not
            recommended</emphasis> unless you have a very controlled
            environment where you will not risk formatting of devices
            with existing data. When <literal>true</literal>, all
            devices/partitions will be used. Is overridden by
            <literal>deviceFilter</literal> if specified.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>deviceFilter</literal>: A regular expression for
            short kernel names of devices (e.g. <literal>sda</literal>)
            that allows selection of devices to be consumed by OSDs. If
            individual devices have been specified for a node then this
            filter will be ignored. This field uses
            <link xlink:href="https://golang.org/pkg/regexp/syntax/">golang
            regular expression syntax</link>. For example:
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>sdb</literal>: Only selects the
                <literal>sdb</literal> device if found
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>^sd.</literal>: Selects all devices starting
                with <literal>sd</literal>
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>^sd[a-d]</literal>: Selects devices starting
                with <literal>sda</literal>, <literal>sdb</literal>,
                <literal>sdc</literal>, and <literal>sdd</literal> if
                found
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>^s</literal>: Selects all devices that start
                with <literal>s</literal>
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>^[^r]</literal>: Selects all devices that do
                <emphasis>not</emphasis> start with <literal>r</literal>
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>devicePathFilter</literal>: A regular expression
            for device paths
            (e.g. <literal>/dev/disk/by-path/pci-0:1:2:3-scsi-1</literal>)
            that allows selection of devices to be consumed by OSDs. If
            individual devices or <literal>deviceFilter</literal> have
            been specified for a node then this filter will be ignored.
            This field uses
            <link xlink:href="https://golang.org/pkg/regexp/syntax/">golang
            regular expression syntax</link>. For example:
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>^/dev/sd.</literal>: Selects all devices
                starting with <literal>sd</literal>
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>^/dev/disk/by-path/pci-.*</literal>: Selects
                all devices which are connected to PCI bus
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>devices</literal>: A list of individual device
            names belonging to this node to include in the storage
            cluster.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>name</literal>: The name of the device (e.g.,
                <literal>sda</literal>), or full udev path
                (e.g. <literal>/dev/disk/by-id/ata-ST4000DM004-XXXX</literal>
                - this will not change after reboots).
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>config</literal>: Device-specific config
                settings. See the
                <link linkend="rook-osd-configuration-settings">config
                settings</link> below
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>storageClassDeviceSets</literal>: Explained in
            <link linkend="rook-storage-class-device-sets">Storage Class
            Device Sets</link>
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-storage-class-device-sets">
      <title>Storage Class Device Sets</title>
      <para>
        The following are the settings for Storage Class Device Sets
        which can be configured to create OSDs that are backed by block
        mode PVs.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>name</literal>: A name for the set.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>count</literal>: The number of devices in the set.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>resources</literal>: The CPU and RAM
            requests/limits for the devices. (Optional)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>placement</literal>: The placement criteria for the
            devices. (Optional) Default is no placement criteria.
          </para>
          <para>
            The syntax is the same as for
            <link linkend="rook-placement-configuration-settings">other
            placement configuration</link>. It supports
            <literal>nodeAffinity</literal>,
            <literal>podAffinity</literal>,
            <literal>podAntiAffinity</literal> and
            <literal>tolerations</literal> keys.
          </para>
          <para>
            It is recommended to configure the placement such that the
            OSDs will be as evenly spread across nodes as possible. At a
            minimum, anti-affinity should be added so at least one OSD
            will be placed on each available nodes.
          </para>
          <para>
            However, if there are more OSDs than nodes, this
            anti-affinity will not be effective. Another placement
            scheme to consider is to add labels to the nodes in such a
            way that the OSDs can be grouped on those nodes, create
            multiple storageClassDeviceSets, and add node affinity to
            each of the device sets that will place the OSDs in those
            sets of nodes.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>preparePlacement</literal>: The placement criteria
            for the preparation of the OSD devices. Creating OSDs is a
            two-step process and the prepare job may require different
            placement than the OSD daemons. If the
            <literal>preparePlacement</literal> is not specified, the
            <literal>placement</literal> will instead be applied for
            consistent placement for the OSD prepare jobs and OSD
            deployments. The <literal>preparePlacement</literal> is only
            useful for <literal>portable</literal> OSDs in the device
            sets. OSDs that are not portable will be tied to the host
            where the OSD prepare job initially runs.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                For example, provisioning may require topology spread
                constraints across zones, but the OSD daemons may
                require constraints across hosts within the zones.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>portable</literal>: If <literal>true</literal>, the
            OSDs will be allowed to move between nodes during failover.
            This requires a storage class that supports portability
            (e.g. <literal>aws-ebs</literal>, but not the local storage
            provisioner). If <literal>false</literal>, the OSDs will be
            assigned to a node permanently. Rook will configure Ceph’s
            CRUSH map to support the portability.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>tuneDeviceClass</literal>: If
            <literal>true</literal>, because the OSD can be on a slow
            device class, Rook will adapt to that by tuning the OSD
            process. This will make Ceph perform better under that slow
            device.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>volumeClaimTemplates</literal>: A list of PVC
            templates to use for provisioning the underlying storage
            devices.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>resources.requests.storage</literal>: The
                desired capacity for the underlying storage devices.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>storageClassName</literal>: The StorageClass to
                provision PVCs from. Default would be to use the
                cluster-default StorageClass. This StorageClass should
                provide a raw block device, multipath device, or logical
                volume. Other types are not supported. If you want to
                use logical volume, please see
                <link xlink:href="ceph-common-issues.md#lvm-metadata-can-be-corrupted-with-osd-on-lv-backed-pvc">known
                issue of OSD on LV-backed PVC</link>
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>volumeMode</literal>: The volume mode to be set
                for the PVC. Which should be Block
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>accessModes</literal>: The access mode for the
                PVC to be bound by OSD.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>schedulerName</literal>: Scheduler name for OSD pod
            placement. (Optional)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>encrypted</literal>: whether to encrypt all the
            OSDs in a given storageClassDeviceSet
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-osd-configuration-settings">
      <title>OSD Configuration Settings</title>
      <para>
        The following storage selection settings are specific to Ceph
        and do not apply to other backends. All variables are key-value
        pairs represented as strings.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>metadataDevice</literal>: Name of a device to use
            for the metadata of OSDs on each node. Performance can be
            improved by using a low latency device (such as SSD or NVMe)
            as the metadata device, while other spinning platter (HDD)
            devices on a node are used to store data. Provisioning will
            fail if the user specifies a
            <literal>metadataDevice</literal> but that device is not
            used as a metadata device by Ceph. Notably,
            <literal>ceph-volume</literal> will not use a device of the
            same device class (HDD, SSD, NVMe) as OSD devices for
            metadata, resulting in this failure.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>storeType</literal>: <literal>bluestore</literal>,
            the underlying storage format to use for each OSD. The
            default is set dynamically to <literal>bluestore</literal>
            for devices and is the only supported format at this point.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>databaseSizeMB</literal>: The size in MB of a
            bluestore database. Include quotes around the size.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>walSizeMB</literal>: The size in MB of a bluestore
            write ahead log (WAL). Include quotes around the size.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>deviceClass</literal>: The
            <link xlink:href="https://ceph.io/community/new-luminous-crush-device-classes/">CRUSH
            device class</link> to use for this selection of storage
            devices. (By default, if a device’s class has not already
            been set, OSDs will automatically set a device’s class to
            either <literal>hdd</literal>, <literal>ssd</literal>, or
            <literal>nvme</literal> based on the hardware properties
            exposed by the Linux kernel.) These storage classes can then
            be used to select the devices backing a storage pool by
            specifying them as the value of
            <link xlink:href="ceph-pool-crd.md#spec">the pool spec’s
            <literal>deviceClass</literal> field</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osdsPerDevice</literal>**: The number of OSDs to
            create on each device. High performance devices such as NVMe
            can handle running multiple OSDs. If desired, this can be
            overridden for each node and each device.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>encryptedDevice</literal>**: Encrypt OSD volumes
            using dmcrypt (<quote>true</quote> or <quote>false</quote>).
            By default this option is disabled. See
            <link xlink:href="http://docs.ceph.com/docs/nautilus/ceph-volume/lvm/encryption/">encryption</link>
            for more information on encryption in Ceph.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        ** <emphasis role="strong">NOTE</emphasis>: Depending on the
        Ceph image running in your cluster, OSDs will be configured
        differently. Newer images will configure OSDs with
        <literal>ceph-volume</literal>, which provides support for
        <literal>osdsPerDevice</literal>,
        <literal>encryptedDevice</literal>, as well as other features
        that will be exposed in future Rook releases. OSDs created prior
        to Rook v0.9 or with older images of Luminous and Mimic are not
        created with <literal>ceph-volume</literal> and thus would not
        support the same features. For <literal>ceph-volume</literal>,
        the following images are supported:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            Luminous 12.2.10 or newer
          </para>
        </listitem>
        <listitem>
          <para>
            Mimic 13.2.3 or newer
          </para>
        </listitem>
        <listitem>
          <para>
            Nautilus
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-storage-selection-via-ceph-drive-groups">
      <title>Storage Selection Via Ceph Drive Groups</title>
      <para>
        Ceph Drive Groups allow for specifying highly advanced OSD
        layouts on nodes including non-homogeneous nodes. They are a way
        to describe a cluster layout using the properties of disks. It
        gives the user an abstract way tell Ceph which disks should turn
        into an OSD with which configuration without knowing the
        specifics of device names and paths. You can target specific
        disks by their device type, by vendor or model, by size, by
        whether they are rotational, and more. Disks with various
        properties can be specified to be data disks or wal/db disks.
      </para>
      <para>
        As a brief example, let’s assume nodes with 20 SSDs and 4 NVMe
        devices. A Drive Group could specify that all SSD devices should
        be data disks and two of the NVMe devices should be wal/db disks
        for the SSDs. That would leave two NVMe devices remaining for
        other usage, either for Ceph or another application.
      </para>
      <para>
        Ceph supports adding devices as OSDs by Ceph Drive Group
        definitions in later versions of Ceph Octopus (v15.2.5+). See
        Ceph Drive Group docs for more info:
        https://docs.ceph.com/docs/master/cephadm/drivegroups/. Drive
        Groups cannot be used to provision OSDs on PVCs.
      </para>
      <blockquote>
        <para>
          <emphasis role="strong">IMPORTANT:</emphasis> When managing a
          Rook/Ceph cluster’s OSD layouts with Drive Groups, the
          <literal>storage</literal> config is mostly ignored.
          <literal>storageClassDeviceSets</literal> can still be used to
          create OSDs on PVC, but Rook will no longer use
          <literal>storage</literal> configs for creating OSDs on a
          node’s devices. To avoid confusion, we recommend using the
          <literal>storage</literal> config OR
          <literal>driveGroups</literal> and never both. Because
          <literal>storage</literal> and <literal>driveGroups</literal>
          should not be used simultaneously, Rook only supports
          provisioning OSDs with Drive Groups on new Rook-Ceph clusters.
        </para>
      </blockquote>
      <para>
        A Drive Group is defined by a name, a Ceph Drive Group spec, and
        a Rook placement * <literal>name</literal>: A name for the Drive
        Group. * <literal>spec</literal>: The Ceph Drive group spec.
        Some components of the spec are treated differently in the
        context of Rook as noted below: * Rook overrides Ceph’s
        definition of <literal>placement</literal> in order to use
        Rook’s <literal>placement</literal> below. * Rook overrides
        Ceph’s deprecated <literal>host_pattern</literal> in order to
        use Rook’s <literal>placement</literal> below. * Rook overrides
        Ceph’s <literal>service_id</literal> field to be the same as the
        Drive Group <literal>name</literal> above. *
        <literal>placement</literal>: The placement criteria for nodes
        to provision with the Drive Group. (Optional) Default is no
        placement criteria, which matches all untainted nodes. The
        syntax is the same as for
        <link linkend="rook-placement-configuration-settings">other placement
        configuration</link>.
      </para>
    </section>
    <section xml:id="rook-annotations-and-labels">
      <title>Annotations and Labels</title>
      <para>
        Annotations and Labels can be specified so that the Rook
        components will have those annotations / labels added to them.
      </para>
      <para>
        You can set annotations / labels for Rook components for the
        list of key value pairs:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>all</literal>: Set annotations / labels for all
            components
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mgr</literal>: Set annotations / labels for MGRs
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mon</literal>: Set annotations / labels for mons
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osd</literal>: Set annotations / labels for OSDs
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>prepareosd</literal>: Set annotations / labels for
            OSD Prepare Jobs
          </para>
        </listitem>
      </itemizedlist>
      <para>
        When other keys are set, <literal>all</literal> will be merged
        together with the specific component.
      </para>
    </section>
    <section xml:id="rook-placement-configuration-settings">
      <title>Placement Configuration Settings</title>
      <para>
        Placement configuration for the cluster services. It includes
        the following keys: <literal>mgr</literal>,
        <literal>mon</literal>, <literal>osd</literal>,
        <literal>cleanup</literal>, and <literal>all</literal>. Each
        service will have its placement configuration generated by
        merging the generic configuration under <literal>all</literal>
        with the most specific one (which will override any attributes).
      </para>
      <para>
        <emphasis role="strong">NOTE:</emphasis> Placement of OSD pods
        is controlled using the
        <link linkend="rook-storage-class-device-sets">Storage Class Device
        Set</link>, not the general <literal>placement</literal>
        configuration.
      </para>
      <para>
        A Placement configuration is specified (according to the
        kubernetes PodSpec) as:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>nodeAffinity</literal>: kubernetes
            <link xlink:href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#node-affinity-beta-feature">NodeAffinity</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>podAffinity</literal>: kubernetes
            <link xlink:href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity-beta-feature">PodAffinity</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>podAntiAffinity</literal>: kubernetes
            <link xlink:href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#inter-pod-affinity-and-anti-affinity-beta-feature">PodAntiAffinity</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>tolerations</literal>: list of kubernetes
            <link xlink:href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">Toleration</link>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>topologySpreadConstraints</literal>: kubernetes
            <link xlink:href="https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/">TopologySpreadConstraints</link>
          </para>
        </listitem>
      </itemizedlist>
      <para>
        If you use <literal>labelSelector</literal> for
        <literal>osd</literal> pods, you must write two rules both for
        <literal>rook-ceph-osd</literal> and
        <literal>rook-ceph-osd-prepare</literal> like
        <link xlink:href="https://github.com/rook/rook/blob/master/cluster/examples/kubernetes/ceph/cluster-on-pvc.yaml#L68">the
        example configuration</link>. It comes from the design that
        there are these two pods for an OSD. For more detail, see the
        <link xlink:href="https://github.com/rook/rook/blob/master/design/ceph/dedicated-osd-pod.md">osd
        design doc</link> and
        <link xlink:href="https://github.com/rook/rook/issues/4582">the
        related issue</link>.
      </para>
      <para>
        The Rook Ceph operator creates a Job called
        <literal>rook-ceph-detect-version</literal> to detect the full
        Ceph version used by the given
        <literal>cephVersion.image</literal>. The placement from the
        <literal>mon</literal> section is used for the Job except for
        the <literal>PodAntiAffinity</literal> field.
      </para>
    </section>
    <section xml:id="rook-cluster-wide-resources-configuration-settings">
      <title>Cluster-wide Resources Configuration Settings</title>
      <para>
        Resources should be specified so that the Rook components are
        handled after
        <link xlink:href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/">Kubernetes
        Pod Quality of Service classes</link>. This allows to keep Rook
        components running when for example a node runs out of memory
        and the Rook components are not killed depending on their
        Quality of Service class.
      </para>
      <para>
        You can set resource requests/limits for Rook components through
        the <link linkend="rook-resource-requirementslimits">Resource
        Requirements/Limits</link> structure in the following keys:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>mgr</literal>: Set resource requests/limits for
            MGRs
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mon</literal>: Set resource requests/limits for
            mons
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osd</literal>: Set resource requests/limits for
            OSDs
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>prepareosd</literal>: Set resource requests/limits
            for OSD prepare job
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>crashcollector</literal>: Set resource
            requests/limits for crash. This pod runs wherever there is a
            Ceph pod running. It scrapes for Ceph daemon core dumps and
            sends them to the Ceph manager crash module so that core
            dumps are centralized and can be easily listed/accessed. You
            can read more about the
            <link xlink:href="https://docs.ceph.com/docs/master/mgr/crash/">Ceph
            Crash module</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>cleanup</literal>: Set resource requests/limits for
            cleanup job, responsible for wiping cluster’s data after
            uninstall
          </para>
        </listitem>
      </itemizedlist>
      <para>
        In order to provide the best possible experience running Ceph in
        containers, Rook internally recommends minimum memory limits if
        resource limits are passed. If a user configures a limit or
        request value that is too low, Rook will still run the pod(s)
        and print a warning to the operator log.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>mon</literal>: 1024MB
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mgr</literal>: 512MB
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osd</literal>: 2048MB
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mds</literal>: 4096MB
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>prepareosd</literal>: 50MB
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>crashcollector</literal>: 60MB
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-resource-requirementslimits">
      <title>Resource Requirements/Limits</title>
      <para>
        For more information on resource requests/limits see the
        official Kubernetes documentation:
        <link xlink:href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container">Kubernetes
        - Managing Compute Resources for Containers</link>
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>requests</literal>: Requests for cpu or memory.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>cpu</literal>: Request for CPU (example: one
                CPU core <literal>1</literal>, 50% of one CPU core
                <literal>500m</literal>).
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>memory</literal>: Limit for Memory (example:
                one gigabyte of memory <literal>1Gi</literal>, half a
                gigabyte of memory <literal>512Mi</literal>).
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>limits</literal>: Limits for cpu or memory.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>cpu</literal>: Limit for CPU (example: one CPU
                core <literal>1</literal>, 50% of one CPU core
                <literal>500m</literal>).
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>memory</literal>: Limit for Memory (example:
                one gigabyte of memory <literal>1Gi</literal>, half a
                gigabyte of memory <literal>512Mi</literal>).
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-priority-class-names-configuration-settings">
      <title>Priority Class Names Configuration Settings</title>
      <para>
        Priority class names can be specified so that the Rook
        components will have those priority class names added to them.
      </para>
      <para>
        You can set priority class names for Rook components for the
        list of key value pairs:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>all</literal>: Set priority class names for MGRs,
            Mons, OSDs.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mgr</literal>: Set priority class names for MGRs.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>mon</literal>: Set priority class names for Mons.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osd</literal>: Set priority class names for OSDs.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The specific component keys will act as overrides to
        <literal>all</literal>.
      </para>
    </section>
    <section xml:id="rook-health-settings">
      <title>Health settings</title>
      <para>
        Rook-Ceph will monitor the state of the CephCluster on various
        components by default. The following CRD settings are available:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>healthCheck</literal>: main ceph cluster health
            monitoring section
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Currently three health checks are implemented:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>mon</literal>: health check on the ceph monitors,
            basically check whether monitors are members of the quorum.
            If after a certain timeout a given monitor has not joined
            the quorum back it will be failed over and replace by a new
            monitor.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osd</literal>: health check on the ceph osds
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>status</literal>: ceph health status check,
            periodically check the Ceph health state and reflects it in
            the CephCluster CR status field.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The liveness probe of each daemon can also be controlled via
        <literal>livenessProbe</literal>, the setting is valid for
        <literal>mon</literal>, <literal>mgr</literal> and
        <literal>osd</literal>. Here is a complete example for both
        <literal>daemonHealth</literal> and
        <literal>livenessProbe</literal>:
      </para>
      <programlisting language="yaml">
healthCheck:
  daemonHealth:
    mon:
      disabled: false
      interval: 45s
      timeout: 600s
    osd:
      disabled: false
      interval: 60s
    status:
      disabled: false
  livenessProbe:
    mon:
      disabled: false
    mgr:
      disabled: false
    osd:
      disabled: false
</programlisting>
      <para>
        The probe itself can also be overridden, refer to the
        <link xlink:href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command">Kubernetes
        documentation</link>.
      </para>
      <para>
        For example, you could change the <literal>mgr</literal> probe
        by applying:
      </para>
      <programlisting language="yaml">
healthCheck:
  livenessProbe:
    mgr:
      disabled: false
      probe:
        httpGet:
          path: /
          port: 9283
        initialDelaySeconds: 3
        periodSeconds: 3
</programlisting>
      <para>
        Changing the liveness probe is an advanced operation and should
        rarely be necessary. If you want to change these settings, start
        with the probe spec Rook generates by default and then modify
        the desired settings.
      </para>
    </section>
  </section>
  <section xml:id="rook-samples">
    <title>Samples</title>
    <para>
      Here are several samples for configuring Ceph clusters. Each of
      the samples must also include the namespace and corresponding
      access granted for management by the Ceph operator. See the
      common cluster resources below.
    </para>
    <section xml:id="rook-storage-configuration-all-devices">
      <title>Storage configuration: All devices</title>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  dashboard:
    enabled: true
  # cluster level storage configuration and selection
  storage:
    useAllNodes: true
    useAllDevices: true
    deviceFilter:
    config:
      metadataDevice:
      databaseSizeMB: &quot;1024&quot; # this value can be removed for environments with normal sized disks (100 GB or larger)
      journalSizeMB: &quot;1024&quot;  # this value can be removed for environments with normal sized disks (20 GB or larger)
      osdsPerDevice: &quot;1&quot;
</programlisting>
    </section>
    <section xml:id="rook-storage-configuration-specific-devices">
      <title>Storage Configuration: Specific devices</title>
      <para>
        Individual nodes and their config can be specified so that only
        the named nodes below will be used as storage resources. Each
        node’s <quote>name</quote> field should match their
        <quote>kubernetes.io/hostname</quote> label.
      </para>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  dashboard:
    enabled: true
  # cluster level storage configuration and selection
  storage:
    useAllNodes: false
    useAllDevices: false
    deviceFilter:
    config:
      metadataDevice:
      databaseSizeMB: &quot;1024&quot; # this value can be removed for environments with normal sized disks (100 GB or larger)
    nodes:
    - name: &quot;172.17.4.201&quot;
      devices:             # specific devices to use for storage can be specified for each node
      - name: &quot;sdb&quot; # Whole storage device
      - name: &quot;sdc1&quot; # One specific partition. Should not have a file system on it.
      - name: &quot;/dev/disk/by-id/ata-ST4000DM004-XXXX&quot; # both device name and explicit udev links are supported
      config:         # configuration can be specified at the node level which overrides the cluster level config
        storeType: bluestore
    - name: &quot;172.17.4.301&quot;
      deviceFilter: &quot;^sd.&quot;
</programlisting>
    </section>
    <section xml:id="rook-node-affinity">
      <title>Node Affinity</title>
      <para>
        To control where various services will be scheduled by
        kubernetes, use the placement configuration sections below. The
        example under <quote>all</quote> would have all services
        scheduled on kubernetes nodes labeled with
        <quote>role=storage-node</quote> and tolerate taints with a key
        of <quote>storage-node</quote>.
      </para>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  # enable the ceph dashboard for viewing cluster status
  dashboard:
    enabled: true
  placement:
    all:
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: role
              operator: In
              values:
              - storage-node
      tolerations:
      - key: storage-node
        operator: Exists
    mgr:
      nodeAffinity:
      tolerations:
    mon:
      nodeAffinity:
      tolerations:
    osd:
      nodeAffinity:
      tolerations:
</programlisting>
    </section>
    <section xml:id="rook-resource-requestslimits">
      <title>Resource Requests/Limits</title>
      <para>
        To control how many resources the Rook components can
        request/use, you can set requests and limits in Kubernetes for
        them. You can override these requests/limits for OSDs per node
        when using <literal>useAllNodes: false</literal> in the
        <literal>node</literal> item in the <literal>nodes</literal>
        list.
      </para>
      <blockquote>
        <para>
          <emphasis role="strong">WARNING</emphasis>: Before setting
          resource requests/limits, please take a look at the Ceph
          documentation for recommendations for each component:
          <link xlink:href="http://docs.ceph.com/docs/master/start/hardware-recommendations/">Ceph
          - Hardware Recommendations</link>.
        </para>
      </blockquote>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  # enable the ceph dashboard for viewing cluster status
  dashboard:
    enabled: true
  # cluster level resource requests/limits configuration
  resources:
  storage:
    useAllNodes: false
    nodes:
    - name: &quot;172.17.4.201&quot;
      resources:
        limits:
          cpu: &quot;2&quot;
          memory: &quot;4096Mi&quot;
        requests:
          cpu: &quot;2&quot;
          memory: &quot;4096Mi&quot;
</programlisting>
    </section>
    <section xml:id="rook-osd-topology">
      <title>OSD Topology</title>
      <para>
        The topology of the cluster is important in production
        environments where you want your data spread across failure
        domains. The topology can be controlled by adding labels to the
        nodes. When the labels are found on a node at first OSD
        deployment, Rook will add them to the desired level in the
        <link xlink:href="http://docs.ceph.com/docs/master/rados/operations/crush-map/">CRUSH
        map</link>.
      </para>
      <para>
        The complete list of labels in hierarchy order from highest to
        lowest is:
      </para>
      <programlisting>
topology.kubernetes.io/region
topology.kubernetes.io/zone
topology.rook.io/datacenter
topology.rook.io/room
topology.rook.io/pod
topology.rook.io/pdu
topology.rook.io/row
topology.rook.io/rack
topology.rook.io/chassis
</programlisting>
      <para>
        For example, if the following labels were added to a node:
      </para>
      <programlisting>
kubectl label node mynode topology.kubernetes.io/zone=zone1
kubectl label node mynode topology.rook.io/rack=rack1
</programlisting>
      <blockquote>
        <para>
          For versions previous to K8s 1.17, use the topology key:
          failure-domain.beta.kubernetes.io/zone or region
        </para>
      </blockquote>
      <para>
        These labels would result in the following hierarchy for OSDs on
        that node (this command can be run in the Rook toolbox):
      </para>
      <programlisting>
[root@mynode /]# ceph osd tree
ID CLASS WEIGHT  TYPE NAME                 STATUS REWEIGHT PRI-AFF
-1       0.01358 root default
-5       0.01358     zone zone1
-4       0.01358         rack rack1
-3       0.01358             host mynode
 0   hdd 0.00679                 osd.0         up  1.00000 1.00000
 1   hdd 0.00679                 osd.1         up  1.00000 1.00000
</programlisting>
      <para>
        Ceph requires unique names at every level in the hierarchy
        (CRUSH map). For example, you cannot have two racks with the
        same name that are in different zones. Racks in different zones
        must be named uniquely.
      </para>
      <para>
        Note that the <literal>host</literal> is added automatically to
        the hierarchy by Rook. The host cannot be specified with a
        topology label. All topology labels are optional.
      </para>
      <blockquote>
        <para>
          <emphasis role="strong">HINT</emphasis> When setting the node
          labels prior to <literal>CephCluster</literal> creation, these
          settings take immediate effect. However, applying this to an
          already deployed <literal>CephCluster</literal> requires
          removing each node from the cluster first and then re-adding
          it with new configuration to take effect. Do this node by node
          to keep your data safe! Check the result with
          <literal>ceph osd tree</literal> from the
          <link xlink:href="ceph-toolbox.md">Rook Toolbox</link>. The
          OSD tree should display the hierarchy for the nodes that
          already have been re-added.
        </para>
      </blockquote>
      <para>
        To utilize the <literal>failureDomain</literal> based on the
        node labels, specify the corresponding option in the
        <link xlink:href="ceph-pool-crd.md">CephBlockPool</link>
      </para>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: replicapool
  namespace: rook-ceph
spec:
  failureDomain: rack  # this matches the topology labels on nodes
  replicated:
    size: 3
</programlisting>
      <para>
        This configuration will split the replication of volumes across
        unique racks in the data center setup.
      </para>
    </section>
    <section xml:id="rook-using-pvc-storage-for-monitors">
      <title>Using PVC storage for monitors</title>
      <para>
        In the CRD specification below three monitors are created each
        using a 10Gi PVC created by Rook using the
        <literal>local-storage</literal> storage class.
      </para>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: false
    volumeClaimTemplate:
      spec:
        storageClassName: local-storage
        resources:
          requests:
            storage: 10Gi
  dashboard:
    enabled: true
  storage:
    useAllNodes: true
    useAllDevices: true
    deviceFilter:
    config:
      metadataDevice:
      databaseSizeMB: &quot;1024&quot; # this value can be removed for environments with normal sized disks (100 GB or larger)
      journalSizeMB: &quot;1024&quot;  # this value can be removed for environments with normal sized disks (20 GB or larger)
      osdsPerDevice: &quot;1&quot;
</programlisting>
    </section>
    <section xml:id="rook-using-storageclassdevicesets">
      <title>Using StorageClassDeviceSets</title>
      <para>
        In the CRD specification below, 3 OSDs (having specific
        placement and resource values) and 3 mons with each using a 10Gi
        PVC, are created by Rook using the
        <literal>local-storage</literal> storage class.
      </para>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: false
    volumeClaimTemplate:
      spec:
        storageClassName: local-storage
        resources:
          requests:
            storage: 10Gi
  cephVersion:
    image: ceph/ceph:v15.2.4
    allowUnsupported: false
  dashboard:
    enabled: true
  network:
    hostNetwork: false
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      resources:
        limits:
          cpu: &quot;500m&quot;
          memory: &quot;4Gi&quot;
        requests:
          cpu: &quot;500m&quot;
          memory: &quot;4Gi&quot;
      placement:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: &quot;rook.io/cluster&quot;
                  operator: In
                  values:
                    - cluster1
                topologyKey: &quot;topology.kubernetes.io/zone&quot;
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          storageClassName: local-storage
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</programlisting>
    </section>
    <section xml:id="rook-dedicated-metadata-and-wal-device-for-osd-on-pvc">
      <title>Dedicated metadata and wal device for OSD on PVC</title>
      <para>
        In the simplest case, Ceph OSD BlueStore consumes a single
        (primary) storage device. BlueStore is the engine used by the
        OSD to store data.
      </para>
      <para>
        The storage device is normally used as a whole, occupying the
        full device that is managed directly by BlueStore. It is also
        possible to deploy BlueStore across additional devices such as a
        DB device. This device can be used for storing BlueStore’s
        internal metadata. BlueStore (or rather, the embedded RocksDB)
        will put as much metadata as it can on the DB device to improve
        performance. If the DB device fills up, metadata will spill back
        onto the primary device (where it would have been otherwise).
        Again, it is only helpful to provision a DB device if it is
        faster than the primary device.
      </para>
      <para>
        You can have multiple <literal>volumeClaimTemplates</literal>
        where each might either represent a device or a metadata device.
        So just taking the <literal>storage</literal> section this will
        give something like:
      </para>
      <programlisting language="yaml">
  storage:
   storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: metadata
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</programlisting>
      <blockquote>
        <para>
          <emphasis role="strong">NOTE</emphasis>: Note that Rook only
          supports three naming convention for a given template:
        </para>
      </blockquote>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <quote>data</quote>: represents the main OSD block device,
            where your data is being stored.
          </para>
        </listitem>
        <listitem>
          <para>
            <quote>metadata</quote>: represents the metadata (including
            block.db and block.wal) device used to store the Ceph
            Bluestore database for an OSD.
          </para>
        </listitem>
        <listitem>
          <para>
            <quote>wal</quote>: represents the block.wal device used to
            store the Ceph Bluestore database for an OSD. If this device
            is set, <quote>metadata</quote> device will refer
            specifically to block.db device. It is recommended to use a
            faster storage class for the metadata or wal device, with a
            slower device for the data. Otherwise, having a separate
            metadata device will not improve the performance.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        The bluestore partition has the following reference combinations
        supported by the ceph-volume utility:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            A single <quote>data</quote> device.
          </para>
          <programlisting language="yaml">
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</programlisting>
        </listitem>
        <listitem>
          <para>
            A <quote>data</quote> device and a <quote>metadata</quote>
            device.
          </para>
          <programlisting language="yaml">
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: metadata
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</programlisting>
        </listitem>
        <listitem>
          <para>
            A <quote>data</quote> device and a <quote>wal</quote>
            device. A WAL device can be used for BlueStore’s internal
            journal or write-ahead log (block.wal), it is only useful to
            use a WAL device if the device is faster than the primary
            device (data device). There is no separate
            <quote>metadata</quote> device in this case, the data of
            main OSD block and block.db located in <quote>data</quote>
            device.
          </para>
          <programlisting language="yaml">
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: wal
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</programlisting>
        </listitem>
        <listitem>
          <para>
            A <quote>data</quote> device, a <quote>metadata</quote>
            device and a <quote>wal</quote> device.
          </para>
          <programlisting language="yaml">
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: metadata
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: wal
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</programlisting>
        </listitem>
      </itemizedlist>
      <para>
        To determine the size of the metadata block follow the
        <link xlink:href="https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing">official
        Ceph sizing guide</link>.
      </para>
      <para>
        With the present configuration, each OSD will have its main
        block allocated a 10GB device as well a 5GB device to act as a
        bluestore database.
      </para>
    </section>
    <section xml:id="rook-external-cluster">
      <title>External cluster</title>
      <para>
        <emphasis role="strong">The minimum supported Ceph version for
        the External Cluster is Luminous 12.2.x.</emphasis>
      </para>
      <para>
        The features available from the external cluster will vary
        depending on the version of Ceph. The following table shows the
        minimum version of Ceph for some of the features:
      </para>
      <informaltable>
        <tgroup cols="2">
          <colspec align="left" />
          <colspec align="left" />
          <thead>
            <row>
              <entry>
                FEATURE
              </entry>
              <entry>
                CEPH VERSION
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                Dynamic provisioning RBD
              </entry>
              <entry>
                12.2.X
              </entry>
            </row>
            <row>
              <entry>
                Configure extra CRDs (object, file, nfs)<footnote>
                  <para>
                    Configure an object store, shared filesystem, or NFS
                    resources in the local cluster to connect to the
                    external Ceph cluster
                  </para>
                </footnote>
              </entry>
              <entry>
                13.2.3
              </entry>
            </row>
            <row>
              <entry>
                Dynamic provisioning CephFS
              </entry>
              <entry>
                14.2.3
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <section xml:id="rook-pre-requisites">
        <title>Pre-requisites</title>
        <para>
          In order to configure an external Ceph cluster with Rook, we
          need to inject some information in order to connect to that
          cluster. You can use the
          <literal>cluster/examples/kubernetes/ceph/import-external-cluster.sh</literal>
          script to achieve that. The script will look for the following
          populated environment variables:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <literal>NAMESPACE</literal>: the namespace where the
              configmap and secrets should be injected
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>ROOK_EXTERNAL_FSID</literal>: the fsid of the
              external Ceph cluster, it can be retrieved via the
              <literal>ceph fsid</literal> command
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>ROOK_EXTERNAL_CEPH_MON_DATA</literal>: is a
              common-separated list of running monitors IP address along
              with their ports, e.g:
              <literal>a=172.17.0.4:6789,b=172.17.0.5:6789,c=172.17.0.6:6789</literal>.
              You don’t need to specify all the monitors, you can simply
              pass one and the Operator will discover the rest. The name
              of the monitor is the name that appears in the
              <literal>ceph status</literal> output.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Now, we need to give Rook a key to connect to the cluster in
          order to perform various operations such as health cluster
          check, CSI keys management etc… It is recommended to generate
          keys with minimal access so the admin key does not need to be
          used by the external cluster. In this case, the admin key is
          only needed to generate the keys that will be used by the
          external cluster. But if the admin key is to be used by the
          external cluster, set the following variable:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <literal>ROOK_EXTERNAL_ADMIN_SECRET</literal>:
              <emphasis role="strong">OPTIONAL:</emphasis> the external
              Ceph cluster admin secret key, it can be retrieved via the
              <literal>ceph auth get-key client.admin</literal> command.
            </para>
          </listitem>
        </itemizedlist>
        <blockquote>
          <para>
            <emphasis role="strong">WARNING</emphasis>: If you plan to
            create CRs (pool, rgw, mds, nfs) in the external cluster,
            you <emphasis role="strong">MUST</emphasis> inject the
            client.admin keyring as well as injecting
            <literal>cluster-external-management.yaml</literal>
          </para>
        </blockquote>
        <para>
          <emphasis role="strong">Example</emphasis>:
        </para>
        <programlisting>
export NAMESPACE=rook-ceph-external
export ROOK_EXTERNAL_FSID=3240b4aa-ddbc-42ee-98ba-4ea7b2a61514
export ROOK_EXTERNAL_CEPH_MON_DATA=a=172.17.0.4:6789
export ROOK_EXTERNAL_ADMIN_SECRET=AQC6Ylxdja+NDBAAB7qy9MEAr4VLLq4dCIvxtg==
</programlisting>
        <para>
          If the Ceph admin key is not provided, the following script
          needs to be executed on a machine that can connect to the Ceph
          cluster using the Ceph admin key. On that machine, run
          <literal>cluster/examples/kubernetes/ceph/create-external-cluster-resources.sh</literal>.
          The script will automatically create users and keys with the
          lowest possible privileges and populate the necessary
          environment variables for
          <literal>cluster/examples/kubernetes/ceph/import-external-cluster.sh</literal>
          to work correctly.
        </para>
        <para>
          Finally, you can simply execute the script like this from a
          machine that has access to your Kubernetes cluster:
        </para>
        <programlisting>
bash cluster/examples/kubernetes/ceph/import-external-cluster.sh
</programlisting>
      </section>
      <section xml:id="rook-cephcluster-example-consumer">
        <title>CephCluster example (consumer)</title>
        <para>
          Assuming the above section has successfully completed, here is
          a CR example:
        </para>
        <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph-external
  namespace: rook-ceph-external
spec:
  external:
    enable: true
  crashCollector:
    disable: true
  # optionally, the ceph-mgr IP address can be pass to gather metric from the prometheus exporter
  #monitoring:
    #enabled: true
    #rulesNamespace: rook-ceph
    #externalMgrEndpoints:
      #- ip: 192.168.39.182
</programlisting>
        <para>
          Choose the namespace carefully, if you have an existing
          cluster managed by Rook, you have likely already injected
          <literal>common.yaml</literal>. Additionally, you now need to
          inject <literal>common-external.yaml</literal> too.
        </para>
        <para>
          You can now create it like this:
        </para>
        <programlisting>
kubectl create -f cluster/examples/kubernetes/ceph/cluster-external.yaml
</programlisting>
        <para>
          If the previous section has not been completed, the Rook
          Operator will still acknowledge the CR creation but will wait
          forever to receive connection information.
        </para>
        <blockquote>
          <para>
            <emphasis role="strong">WARNING</emphasis>: If no cluster is
            managed by the current Rook Operator, you need to inject
            <literal>common.yaml</literal>, then modify
            <literal>cluster-external.yaml</literal> and specify
            <literal>rook-ceph</literal> as
            <literal>namespace</literal>.
          </para>
        </blockquote>
        <para>
          If this is successfull you will see the CepCluster status as
          connected.
        </para>
        <programlisting>
kubectl get CephCluster -n rook-ceph-external
NAME                 DATADIRHOSTPATH   MONCOUNT   AGE    STATE       HEALTH
rook-ceph-external   /var/lib/rook                162m   Connected   HEALTH_OK
</programlisting>
        <para>
          Before you create a StorageClass with this cluster you will
          need to create a Pool in your external Ceph Cluster.
        </para>
      </section>
      <section xml:id="rook-example-storageclass-based-on-external-ceph-pool">
        <title>Example StorageClass based on external Ceph Pool</title>
        <para>
          In Ceph Cluster let us list the pools available:
        </para>
        <programlisting>
rados df
POOL_NAME     USED OBJECTS CLONES COPIES MISSING_ON_PRIMARY UNFOUND DEGRADED RD_OPS  RD WR_OPS  WR USED COMPR UNDER COMPR
replicated_2g  0 B       0      0      0                  0       0        0      0 0 B      0 0 B        0 B         0 B
</programlisting>
        <para>
          Here is an example StorageClass configuration that uses the
          <literal>replicated_2g</literal> pool from the external
          cluster:
        </para>
        <programlisting>
cat &lt;&lt; EOF | kubectl apply -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
   name: rook-ceph-block-ext
# Change &quot;rook-ceph&quot; provisioner prefix to match the operator namespace if needed
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
    # clusterID is the namespace where the rook cluster is running
    clusterID: rook-ceph-external
    # Ceph pool into which the RBD image shall be created
    pool: replicated_2g

    # RBD image format. Defaults to &quot;2&quot;.
    imageFormat: &quot;2&quot;

    # RBD image features. Available for imageFormat: &quot;2&quot;. CSI RBD currently supports only `layering` feature.
    imageFeatures: layering

    # The secrets contain Ceph admin credentials.
    csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner
    csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph-external
    csi.storage.k8s.io/controller-expand-secret-name: rook-csi-rbd-provisioner
    csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph-external
    csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node
    csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph-external

    # Specify the filesystem type of the volume. If not specified, csi-provisioner
    # will set default as `ext4`. Note that `xfs` is not recommended due to potential deadlock
    # in hyperconverged settings where the volume is mounted on the same node as the osds.
    csi.storage.k8s.io/fstype: ext4

# Delete the rbd volume when a PVC is deleted
reclaimPolicy: Delete
allowVolumeExpansion: true
EOF
</programlisting>
        <para>
          You can now create a persistent volume based on this
          StorageClass.
        </para>
      </section>
      <section xml:id="rook-cephcluster-example-management">
        <title>CephCluster example (management)</title>
        <para>
          The following CephCluster CR represents a cluster that will
          perform management tasks on the external cluster. It will not
          only act as a consumer but will also allow the deployment of
          other CRDs such as CephFilesystem or CephObjectStore. As
          mentioned above, you would need to inject the admin keyring
          for that.
        </para>
        <para>
          The corresponding YAML example:
        </para>
        <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph-external
  namespace: rook-ceph-external
spec:
  external:
    enable: true
  dataDirHostPath: /var/lib/rook
  cephVersion:
    image: ceph/ceph:v15.2.4 # Should match external cluster version
</programlisting>
      </section>
    </section>
    <section xml:id="rook-cleanup-policy">
      <title>Cleanup policy</title>
      <para>
        Rook has the ability to cleanup resources and data that were
        deployed when a <literal>delete cephcluster</literal> command is
        issued. The policy represents the confirmation that cluster data
        should be forcibly deleted. The cleanupPolicy should only be
        added to the cluster when the cluster is about to be deleted.
        After the <literal>confirmation</literal> field of the cleanup
        policy is set, Rook will stop configuring the cluster as if the
        cluster is about to be destroyed in order to prevent these
        settings from being deployed unintentionally. The
        <literal>cleanupPolicy</literal> CR settings has different
        fields:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>confirmation</literal>: Only an empty string and
            <literal>yes-really-destroy-data</literal> are valid values
            for this field. If an empty string is set, Rook will only
            remove Ceph’s metadata. A re-installation will not be
            possible unless the hosts are cleaned first. If
            <literal>yes-really-destroy-data</literal> the operator will
            automatically delete data on the hostpath of cluster nodes
            and clean devices with OSDs. The cluster can then be
            re-installed if desired with no further steps.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>sanitizeDisks</literal>: sanitizeDisks represents
            advanced settings that can be used to sanitize drives. This
            field only affects if <literal>confirmation</literal> is set
            to <literal>yes-really-destroy-data</literal>. However, the
            administrator might want to sanitize the drives in more
            depth with the following flags:
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>method</literal>: indicates if the entire disk
                should be sanitized or simply ceph’s metadata. Possible
                choices are <quote>quick</quote> (default) or
                <quote>complete</quote>
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>dataSource</literal>: indicate where to get
                random bytes from to write on the disk. Possible choices
                are <quote>zero</quote> (default) or
                <quote>random</quote>. Using random sources will consume
                entropy from the system and will take much more time
                then the zero source
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>iteration</literal>: overwrite N times instead
                of the default (1). Takes an integer value
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>allowUninstallWithVolumes</literal>: If set to
            true, then the cephCluster deletion doesn’t wait for the
            PVCs to be deleted. Default is false.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        To automate activation of the cleanup, you can use the following
        command. <emphasis role="strong">WARNING: DATA WILL BE
        PERMANENTLY DELETED</emphasis>:
      </para>
      <programlisting>
kubectl -n rook-ceph patch cephcluster rook-ceph --type merge -p '{&quot;spec&quot;:{&quot;cleanupPolicy&quot;:{&quot;confirmation&quot;:&quot;yes-really-destroy-data&quot;}}}'
</programlisting>
      <para>
        Nothing will happen until the deletion of the CR is requested,
        so this can still be reverted. However, all new configuration by
        the operator will be blocked with this cleanup policy enabled.
      </para>
      <para>
        Rook waits for the deletion of PVs provisioned using the
        cephCluster before proceeding to delete the cephCluster. To
        force deletion of the cephCluster without waiting for the PVs to
        be deleted, you can set the allowUninstallWithVolumes to true
        under spec.CleanupPolicy.
      </para>
    </section>
  </section>
  </section>

  <section xml:id="rook-ceph-block-pool-crd">
  <title>Ceph Block Pool CRD</title>
  <para>
    Rook allows creation and customization of storage pools through the
    custom resource definitions (CRDs). The following settings are
    available for pools.
  </para>
  <section xml:id="rook-samples-rep">
    <title>Samples</title>
    <section xml:id="replicated">
      <title>Replicated</title>
      <para>
        For optimal performance, while also adding redundancy, this
        sample will configure Ceph to make three full copies of the data
        on multiple nodes.
      </para>
      <blockquote>
        <para>
          <emphasis role="strong">NOTE</emphasis>: This sample requires
          <emphasis>at least 1 OSD per node</emphasis>, with each OSD
          located on <emphasis>3 different nodes</emphasis>.
        </para>
      </blockquote>
      <para>
        Each OSD must be located on a different node, because the
        <link xlink:href="ceph-pool-crd.md#spec"><literal>failureDomain</literal></link>
        is set to <literal>host</literal> and the
        <literal>replicated.size</literal> is set to
        <literal>3</literal>.
      </para>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: replicapool
  namespace: rook-ceph
spec:
  failureDomain: host
  replicated:
    size: 3
  deviceClass: hdd
</programlisting>
    </section>
    <section xml:id="rook-erasure-coded-sample">
      <title>Erasure Coded</title>
      <para>
        This sample will lower the overall storage capacity requirement,
        while also adding redundancy by using
        <link linkend="rook-erasure-coding">erasure coding</link>.
      </para>
      <blockquote>
        <para>
          <emphasis role="strong">NOTE</emphasis>: This sample requires
          <emphasis>at least 3 bluestore OSDs</emphasis>.
        </para>
      </blockquote>
      <para>
        The OSDs can be located on a single Ceph node or spread across
        multiple nodes, because the
        <link xlink:href="ceph-pool-crd.md#spec"><literal>failureDomain</literal></link>
        is set to <literal>osd</literal> and the
        <literal>erasureCoded</literal> chunk settings require at least
        3 different OSDs (2 <literal>dataChunks</literal> + 1
        <literal>codingChunks</literal>).
      </para>
      <programlisting language="yaml">
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: ecpool
  namespace: rook-ceph
spec:
  failureDomain: osd
  erasureCoded:
    dataChunks: 2
    codingChunks: 1
  deviceClass: hdd
</programlisting>
      <para>
        High performance applications typically will not use erasure
        coding due to the performance overhead of creating and
        distributing the chunks in the cluster.
      </para>
      <para>
        When creating an erasure-coded pool, it is highly recommended to
        create the pool when you have <emphasis role="strong">bluestore
        OSDs</emphasis> in your cluster (see the
        <link xlink:href="ceph-cluster-crd.md#osd-configuration-settings">OSD
        configuration settings</link>. Filestore OSDs have
        <link xlink:href="http://docs.ceph.com/docs/master/rados/operations/erasure-code/#erasure-coding-with-overwrites">limitations</link>
        that are unsafe and lower performance.
      </para>
    </section>
  </section>
  <section xml:id="rook-pool-settings">
    <title>Pool Settings</title>
    <section xml:id="rook-metadata-pool-settings">
      <title>Metadata</title>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>name</literal>: The name of the pool to create.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>namespace</literal>: The namespace of the Rook
            cluster where the pool is created.
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-spec">
      <title>Spec</title>
      <itemizedlist>
        <listitem>
          <para>
            <literal>replicated</literal>: Settings for a replicated
            pool. If specified, <literal>erasureCoded</literal> settings
            must not be specified.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>size</literal>: The desired number of copies to
                make of the data in the pool.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>requireSafeReplicaSize</literal>: set to false
                if you want to create a pool with size 1, setting pool
                size 1 could lead to data loss without recovery. Make
                sure you are <emphasis>ABSOLUTELY CERTAIN</emphasis>
                that is what you want.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>erasureCoded</literal>: Settings for an
            erasure-coded pool. If specified,
            <literal>replicated</literal> settings must not be
            specified. See below for more details on
            <link linkend="rook-erasure-coding">erasure coding</link>.
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>dataChunks</literal>: Number of chunks to
                divide the original object into
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>codingChunks</literal>: Number of coding chunks
                to generate
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <literal>failureDomain</literal>: The failure domain across
            which the data will be spread. This can be set to a value of
            either <literal>osd</literal> or <literal>host</literal>,
            with <literal>host</literal> being the default setting. A
            failure domain can also be set to a different type
            (e.g. <literal>rack</literal>), if it is added as a
            <literal>location</literal> in the
            <link xlink:href="ceph-cluster-crd.md#storage-selection-settings">Storage
            Selection Settings</link>. If a
            <literal>replicated</literal> pool of size
            <literal>3</literal> is configured and the
            <literal>failureDomain</literal> is set to
            <literal>host</literal>, all three copies of the replicated
            data will be placed on OSDs located on <literal>3</literal>
            different Ceph hosts. This case is guaranteed to tolerate a
            failure of two hosts without a loss of data. Similarly, a
            failure domain set to <literal>osd</literal>, can tolerate a
            loss of two OSD devices.
          </para>
          <para>
            If erasure coding is used, the data and coding chunks are
            spread across the configured failure domain.
          </para>
          <blockquote>
            <para>
              <emphasis role="strong">NOTE</emphasis>: Neither Rook, nor
              Ceph, prevent the creation of a cluster where the
              replicated data (or Erasure Coded chunks) can be written
              safely. By design, Ceph will delay checking for suitable
              OSDs until a write request is made and this write can hang
              if there are not sufficient OSDs to satisfy the request.
            </para>
          </blockquote>
        </listitem>
        <listitem>
          <para>
            <literal>deviceClass</literal>: Sets up the CRUSH rule for
            the pool to distribute data only on the specified device
            class. If left empty or unspecified, the pool will use the
            cluster’s default CRUSH root, which usually distributes data
            over all OSDs, regardless of their class.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>crushRoot</literal>: The root in the crush map to
            be used by the pool. If left empty or unspecified, the
            default root will be used. Creating a crush hierarchy for
            the OSDs currently requires the Rook toolbox to run the Ceph
            tools described
            <link xlink:href="http://docs.ceph.com/docs/master/rados/operations/crush-map/#modifying-the-crush-map">here</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>enableRBDStats</literal>: Enables collecting RBD
            per-image IO statistics by enabling dynamic OSD performance
            counters. Defaults to false. For more info see the
            <link xlink:href="https://docs.ceph.com/docs/master/mgr/prometheus/#rbd-io-statistics">ceph
            documentation</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>parameters</literal>: Sets any
            <link xlink:href="https://docs.ceph.com/docs/master/rados/operations/pools/#set-pool-values">parameters</link>
            listed to the given pool
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <literal>target_size_ratio:</literal> gives a hint (%)
                to Ceph in terms of expected consumption of the total
                cluster capacity of a given pool, for more info see the
                <link xlink:href="https://docs.ceph.com/docs/master/rados/operations/placement-groups/#specifying-expected-pool-size">ceph
                documentation</link>
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>compression_mode</literal>: Sets up the pool
                for inline compression when using a Bluestore OSD. If
                left unspecified does not setup any compression mode for
                the pool. Values supported are the same as Bluestore
                inline compression
                <link xlink:href="https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#inline-compression">modes</link>,
                such as <literal>none</literal>,
                <literal>passive</literal>,
                <literal>aggressive</literal>, and
                <literal>force</literal>.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="rook-add-specific-pool-properties">
      <title>Add specific pool properties</title>
      <para>
        With <literal>poolProperties</literal> you can set any pool
        property:
      </para>
      <programlisting language="yaml">
spec:
  parameters:
    &lt;name of the parameter&gt;: &lt;parameter value&gt;
</programlisting>
      <para>
        For instance:
      </para>
      <programlisting language="yaml">
spec:
  parameters:
    min_size: 1
</programlisting>
    </section>
    <section xml:id="rook-erasure-coding">
      <title>Erasure Coding</title>
      <para>
        <link xlink:href="http://docs.ceph.com/docs/master/rados/operations/erasure-code/">Erasure
        coding</link> allows you to keep your data safe while reducing
        the storage overhead. Instead of creating multiple replicas of
        the data, erasure coding divides the original data into chunks
        of equal size, then generates extra chunks of that same size for
        redundancy.
      </para>
      <para>
        For example, if you have an object of size 2MB, the simplest
        erasure coding with two data chunks would divide the object into
        two chunks of size 1MB each (data chunks). One more chunk
        (coding chunk) of size 1MB will be generated. In total, 3MB will
        be stored in the cluster. The object will be able to suffer the
        loss of any one of the chunks and still be able to reconstruct
        the original object.
      </para>
      <para>
        The number of data and coding chunks you choose will depend on
        your resiliency to loss and how much storage overhead is
        acceptable in your storage cluster. Here are some examples to
        illustrate how the number of chunks affects the storage and loss
        toleration.
      </para>
      <informaltable>
        <tgroup cols="5">
          <colspec colwidth="20*" align="left" />
          <colspec colwidth="22*" align="left" />
          <colspec colwidth="17*" align="left" />
          <colspec colwidth="21*" align="left" />
          <colspec colwidth="17*" align="left" />
          <thead>
            <row>
              <entry>
                Data chunks (k)
              </entry>
              <entry>
                Coding chunks (m)
              </entry>
              <entry>
                Total storage
              </entry>
              <entry>
                Losses Tolerated
              </entry>
              <entry>
                OSDs required
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                2
              </entry>
              <entry>
                1
              </entry>
              <entry>
                1.5x
              </entry>
              <entry>
                1
              </entry>
              <entry>
                3
              </entry>
            </row>
            <row>
              <entry>
                2
              </entry>
              <entry>
                2
              </entry>
              <entry>
                2x
              </entry>
              <entry>
                2
              </entry>
              <entry>
                4
              </entry>
            </row>
            <row>
              <entry>
                4
              </entry>
              <entry>
                2
              </entry>
              <entry>
                1.5x
              </entry>
              <entry>
                2
              </entry>
              <entry>
                6
              </entry>
            </row>
            <row>
              <entry>
                16
              </entry>
              <entry>
                4
              </entry>
              <entry>
                1.25x
              </entry>
              <entry>
                4
              </entry>
              <entry>
                20
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
        The <literal>failureDomain</literal> must be also be taken into
        account when determining the number of chunks. The failure
        domain determines the level in the Ceph CRUSH hierarchy where
        the chunks must be uniquely distributed. This decision will
        impact whether node losses or disk losses are tolerated. There
        could also be performance differences of placing the data across
        nodes or osds.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>host</literal>: All chunks will be placed on unique
            hosts
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osd</literal>: All chunks will be placed on unique
            OSDs
          </para>
        </listitem>
      </itemizedlist>
      <para>
        If you do not have a sufficient number of hosts or OSDs for
        unique placement the pool can be created, writing to the pool
        will hang.
      </para>
      <para>
        Rook currently only configures two levels in the CRUSH map. It
        is also possible to configure other levels such as
        <literal>rack</literal> with by adding
        <link xlink:href="ceph-cluster-crd.md#osd-topology">topology
        labels</link> to the nodes.
      </para>
    </section>
  </section>
</section>

  <section xml:id="rook-ceph-shared-filesystem-crd">
    <title>Ceph Shared Filesystem CRD</title>
    <para>
      Rook allows creation and customization of shared filesystems through
      the custom resource definitions (CRDs). The following settings are
      available for Ceph filesystems.
    </para>
    <section xml:id="rook-samples-rook-rep">
      <title>Samples</title>
      <section xml:id="rook-replicated">
        <title>Replicated</title>
        <blockquote>
          <para>
            <emphasis role="strong">NOTE</emphasis>: This sample requires
            <emphasis>at least 1 OSD per node</emphasis>, with each OSD
            located on <emphasis>3 different nodes</emphasis>.
          </para>
        </blockquote>
        <para>
          Each OSD must be located on a different node, because both of
          the defined pools set the
          <link xlink:href="ceph-pool-crd.md#spec"><literal>failureDomain</literal></link>
          to <literal>host</literal> and the
          <literal>replicated.size</literal> to <literal>3</literal>.
        </para>
        <para>
          The <literal>failureDomain</literal> can also be set to another
          location type (e.g. <literal>rack</literal>), if it has been
          added as a <literal>location</literal> in the
          <link xlink:href="ceph-cluster-crd.md#storage-selection-settings">Storage
            Selection Settings</link>.
        </para>
        <programlisting language="yaml">
          apiVersion: ceph.rook.io/v1
          kind: CephFilesystem
          metadata:
          name: myfs
          namespace: rook-ceph
          spec:
          metadataPool:
          failureDomain: host
          replicated:
          size: 3
          dataPools:
          - failureDomain: host
          replicated:
          size: 3
          preservePoolsOnDelete: true
          metadataServer:
          activeCount: 1
          activeStandby: true
          # A key/value list of annotations
          annotations:
          #  key: value
          placement:
          #  nodeAffinity:
          #    requiredDuringSchedulingIgnoredDuringExecution:
          #      nodeSelectorTerms:
          #      - matchExpressions:
          #        - key: role
          #          operator: In
          #          values:
          #          - mds-node
          #  tolerations:
          #  - key: mds-node
          #    operator: Exists
          #  podAffinity:
          #  podAntiAffinity:
          #  topologySpreadConstraints:
          resources:
          #  limits:
          #    cpu: &quot;500m&quot;
          #    memory: &quot;1024Mi&quot;
          #  requests:
          #    cpu: &quot;500m&quot;
          #    memory: &quot;1024Mi&quot;
        </programlisting>
        <para>
          (These definitions can also be found in the
          <link xlink:href="https://github.com/rook/rook/blob/%7B%7B%20branchName%20%7D%7D/cluster/examples/kubernetes/ceph/filesystem.yaml"><literal>filesystem.yaml</literal></link>
          file)
        </para>
      </section>
      <section xml:id="rook-erasure-coded">
        <title>Erasure Coded</title>
        <para>
          Erasure coded pools require the OSDs to use
          <literal>bluestore</literal> for the configured
          <link xlink:href="ceph-cluster-crd.md#osd-configuration-settings"><literal>storeType</literal></link>.
          Additionally, erasure coded pools can only be used with
          <literal>dataPools</literal>. The
          <literal>metadataPool</literal> must use a replicated pool.
        </para>
        <blockquote>
          <para>
            <emphasis role="strong">NOTE</emphasis>: This sample requires
            <emphasis>at least 3 bluestore OSDs</emphasis>, with each OSD
            located on a <emphasis>different node</emphasis>.
          </para>
        </blockquote>
        <para>
          The OSDs must be located on different nodes, because the
          <link xlink:href="ceph-pool-crd.md#spec"><literal>failureDomain</literal></link>
          will be set to <literal>host</literal> by default, and the
          <literal>erasureCoded</literal> chunk settings require at least
          3 different OSDs (2 <literal>dataChunks</literal> + 1
          <literal>codingChunks</literal>).
        </para>
        <programlisting language="yaml">
          apiVersion: ceph.rook.io/v1
          kind: CephFilesystem
          metadata:
          name: myfs-ec
          namespace: rook-ceph
          spec:
          metadataPool:
          replicated:
          size: 3
          dataPools:
          - erasureCoded:
          dataChunks: 2
          codingChunks: 1
          metadataServer:
          activeCount: 1
          activeStandby: true
        </programlisting>
        <para>
          (These definitions can also be found in the
          <link xlink:href="https://github.com/rook/rook/blob/%7B%7B%20branchName%20%7D%7D/cluster/examples/kubernetes/ceph/filesystem-ec.yaml"><literal>filesystem-ec.yaml</literal></link>
          file)
        </para>
      </section>
    </section>
    <section xml:id="rook-filesystem-settings">
      <title>Filesystem Settings</title>
      <section xml:id="rook-metadata-filesystem">
        <title>Metadata</title>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <literal>name</literal>: The name of the filesystem to
              create, which will be reflected in the pool and other
              resource names.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>namespace</literal>: The namespace of the Rook
              cluster where the filesystem is created.
            </para>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="rook-pools">
        <title>Pools</title>
        <para>
          The pools allow all of the settings defined in the Pool CRD
          spec. For more details, see the
          <link xlink:href="ceph-pool-crd.md">Pool CRD</link> settings. In
          the example above, there must be at least three hosts (size 3)
          and at least eight devices (6 data + 2 coding chunks) in the
          cluster.
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <literal>metadataPool</literal>: The settings used to create
              the filesystem metadata pool. Must use replication.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>dataPools</literal>: The settings to create the
              filesystem data pools. If multiple pools are specified, Rook
              will add the pools to the filesystem. Assigning users or
              files to a pool is left as an exercise for the reader with
              the
              <link xlink:href="http://docs.ceph.com/docs/master/cephfs/file-layouts/">CephFS
                documentation</link>. The data pools can use replication or
              erasure coding. If erasure coding pools are specified, the
              cluster must be running with bluestore enabled on the OSDs.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>preservePoolsOnDelete</literal>: If it is set to
              <quote>true</quote> the pools used to support the filesystem
              will remain when the filesystem will be deleted. This is a
              security measure to avoid accidental loss of data. It is set
              to <quote>false</quote> by default. If not specified is also
              deemed as <quote>false</quote>.
            </para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <section xml:id="rook-metadata-server-settings">
      <title>Metadata Server Settings</title>
      <para>
        The metadata server settings correspond to the MDS daemon
        settings.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>activeCount</literal>: The number of active MDS
            instances. As load increases, CephFS will automatically
            partition the filesystem across the MDS instances. Rook will
            create double the number of MDS instances as requested by the
            active count. The extra instances will be in standby mode for
            failover.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>activeStandby</literal>: If true, the extra MDS
            instances will be in active standby mode and will keep a warm
            cache of the filesystem metadata for faster failover. The
            instances will be assigned by CephFS in failover pairs. If
            false, the extra MDS instances will all be on passive standby
            mode and will not maintain a warm cache of the metadata.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>annotations</literal>: Key value pair list of
            annotations to add.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>labels</literal>: Key value pair list of labels to
            add.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>placement</literal>: The mds pods can be given
            standard Kubernetes placement restrictions with
            <literal>nodeAffinity</literal>,
            <literal>tolerations</literal>,
            <literal>podAffinity</literal>, and
            <literal>podAntiAffinity</literal> similar to placement
            defined for daemons configured by the
            <link xlink:href="https://github.com/rook/rook/blob/%7B%7B%20branchName%20%7D%7D/cluster/examples/kubernetes/ceph/cluster.yaml">cluster
              CRD</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>resources</literal>: Set resource requests/limits for
            the Filesystem MDS Pod(s), see
            <link xlink:href="ceph-cluster-crd.md#resource-requirementslimits">Resource
              Requirements/Limits</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>priorityClassName</literal>: Set priority class name
            for the Filesystem MDS Pod(s)
          </para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

</chapter>

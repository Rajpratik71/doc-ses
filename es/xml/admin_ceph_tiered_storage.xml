<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_ceph_tiered_storage.xml" version="5.0" xml:id="cha-ceph-tiered">

 <title>Niveles de caché</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:maintainer>tbazant@suse.com</dm:maintainer>
        <dm:status>editar</dm:status>
        <dm:deadline/>
        <dm:priority/>
        <dm:translation>sí</dm:translation>
        <dm:languages/>
        <dm:release>SES 5</dm:release>
      </dm:docmanager>
    </info>
    <para>
  Un <emphasis>nivel de caché</emphasis> es una capa de almacenamiento adicional implementada entre el cliente y el almacenamiento estándar. Está diseñado para agilizar el acceso a los repositorios almacenados en discos duros lentos y los repositorios codificados de borrado.
 </para>
 <para>
  Por lo general, la existencia de niveles de caché implica la creación de un repositorio de dispositivos de almacenamiento relativamente rápidos y caros (por ejemplo, unidades SSD), configurados para actuar como un nivel de caché, así como un repositorio de copia de seguridad con dispositivos más lentos y menos costosos, configurados como nivel de almacenamiento.
 </para>
 <sect1>
  <title>Terminología de almacenamiento por niveles</title>

  <para>
   Los niveles de caché reconocen dos tipos de repositorios: un <emphasis>repositorio de caché</emphasis> y un <emphasis>repositorio de almacenamiento.</emphasis>
  </para>

  <tip>
   <para>
    Para obtener información general sobre los repositorios, consulte el <xref linkend="ceph-pools"/>.
   </para>
  </tip>

  <variablelist>
   <varlistentry>
    <term>repositorio de almacenamiento</term>
    <listitem>
     <para>
      Puede ser un repositorio estándar replicado que almacena varias copias de un objeto en el clúster de almacenamiento Ceph o un repositorio codificado de borrado (consulte el <xref linkend="cha-ceph-erasure"/>).
     </para>
     <para>
      El repositorio de almacenamiento se conoce a veces como almacenamiento de "copia de seguridad" o "en frío".
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>repositorio de caché</term>
    <listitem>
     <para>
      Un repositorio estándar replicado, almacenado en un dispositivo de almacenamiento relativamente pequeño pero rápido, con su propio conjunto de reglas, en una asignación CRUSH.
     </para>
     <para>
      El repositorio de caché también se conoce como almacenamiento "en caliente".
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-ceph-tiered-caution">
  <title>Puntos que se deben tener en cuenta</title>

  <para>
   Los niveles de caché pueden <emphasis>degradar</emphasis> el rendimiento del clúster para cargas de trabajo específicas. A continuación, describiremos algunos de los aspectos que debe tener en cuenta:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <emphasis>Dependencia de la carga de trabajo:</emphasis> las posibles mejoras de rendimiento del caché dependen de la carga de trabajo. Dado que existe un coste asociado a introducir objetos en el caché o sacarlos de él, puede ser más eficaz cuando la mayoría de las peticiones afectan a un pequeño número de objetos. El repositorio de caché debe ser lo suficientemente grande como para capturar el espacio de trabajo, de modo que la carga de trabajo evite la hiperpaginación.
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis>Dificultad para establecer una comparativa:</emphasis> la mayoría de las comparativas de rendimiento pueden mostrar un bajo rendimiento con niveles de caché. El motivo es que piden un conjunto extenso de objetos y el caché tarda mucho en "entrar en calor".
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis>Probabilidad de bajo rendimiento:</emphasis> en las cargas de trabajo inadecuadas para los niveles de caché, el rendimiento suele ser más lento que el de un repositorio normal replicado sin niveles de caché.
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis>Enumeración de objetos de <systemitem>librados</systemitem>:</emphasis> si la aplicación usa <systemitem>librados</systemitem> directamente y se basa en la enumeración de objetos, los niveles de caché podrían no funcionar del modo previsto. (Esto no es un problema para Object Gateway, RBD o CephFS).
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1>
  <title>Cuándo usar los niveles de caché</title>

  <para>
   Plantéese usar los niveles de caché en los siguientes casos:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Necesita acceso a repositorios codificados de borrado a través del dispositivo de bloques RADOS (RBD).
    </para>
   </listitem>
   <listitem>
    <para>
     Necesita acceso a repositorios codificados de borrado a través de iSCSI, ya que hereda las limitaciones de RBD. Para obtener más información acerca de iSCSI, consulte el <xref linkend="cha-ceph-iscsi"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     Tiene un número limitado de dispositivos de almacenamiento de alto rendimiento y un gran conjunto de dispositivos de bajo rendimiento y necesita acceder a los datos almacenados con mayor rapidez.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec-ceph-tiered-cachemodes">
  <title>Modos de caché</title>

  <para>
   El agente de niveles de caché gestiona la migración de datos entre el nivel de caché y el de almacenamiento. Los administradores pueden configurar el modo en que se produce esta migración. Existen dos escenarios principales:
  </para>

  <variablelist>
   <varlistentry>
    <term>modo de escritura diferida</term>
    <listitem>
     <para>
      En el modo de escritura diferida, los clientes Ceph escriben datos en el nivel de caché y reciben una señal ACK de este. Posteriormente, los datos escritos en el nivel de caché pasan al nivel de almacenamiento y se eliminan del caché. Conceptualmente, el nivel de caché se superpone "delante" del nivel de almacenamiento. Cuando un cliente Ceph necesita datos que se encuentran en el nivel de almacenamiento, el agente de niveles de caché mueve los datos al espacio de lectura del nivel de caché, que pasa a enviarlos al cliente Ceph. A partir de ahí, el cliente Ceph puede llevar a cabo operaciones de E/S con el nivel de caché hasta que los datos se vuelven inactivos. Esto resulta idóneo para datos modificables, como edición de fotografías y vídeos o datos transaccionales.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>modo de solo lectura</term>
    <listitem>
     <para>
      En el modo de solo lectura, los clientes Ceph escriben los datos directamente en el nivel de almacenamiento. Al leer, Ceph copia los objetos solicitados del nivel de copia de seguridad al de caché. Los objetos obsoletos se eliminan del nivel de caché según la directiva definida. Este enfoque es idóneo para obtener datos inmutables, como la presentación de fotos o vídeos en una red social, datos de ADN o radiografías, ya que leer datos desde un repositorio de caché que podría incluir datos obsoletos ofrecería menos fiabilidad. No utilice el modo de solo lectura para datos modificables.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="ses-tiered-hitset">
  <title>Conjunto de resultados</title>

  <sect2 xml:id="ses-tiered-hitset-overview">
   <title>Descripción general</title>
   <para>
    Los parámetros de <emphasis>Hit set</emphasis> (Conjunto de resultados) permiten ajustar los <emphasis>repositorios de caché</emphasis>. Los conjuntos de resultados de Ceph suelen ser filtros de Bloom y proporcionan un modo eficaz de asignar memoria al seguimiento de los objetos que se encuentran en el repositorio de caché.
   </para>
   <para>
    El conjunto de resultados es una matriz de bits que se utiliza para almacenar el resultado de un conjunto de funciones de hash aplicadas a nombres de objetos. Inicialmente, todos los bits se establecen como <literal>0</literal>. Cuando un objeto se añade al conjunto de resultados, su nombre se almacena en un valor hash y el resultado se asigna a diferentes posiciones del conjunto de resultados, donde el valor de bit se establece como <literal>1</literal>.
   </para>
   <para>
    Para averiguar si un objeto existe en el caché, se vuelve a convertir su nombre en un valor hash. Si algún bit es <literal>0</literal>, el objeto no está en el caché y hay que recuperarlo del almacenamiento en frío.<remark role="fixme">How is the modification date retrieved in read mode?</remark>
   </para>
   <para>
    Es posible que los resultados de diferentes objetos estén almacenados en la misma posición del conjunto de resultados. El azar puede provocar que todos los bits sean <literal>1</literal> sin que el objeto esté en el caché. Por lo tanto, los conjuntos de resultados que funcionan con un filtro de Bloom solo pueden distinguir con total seguridad que un objeto no está en el caché y es necesario recuperarlo del almacenamiento en frío.
   </para>
   <para>
    Un repositorio de caché puede tener más de un conjunto de resultados para realizar un seguimiento del acceso a los archivos a lo largo del tiempo. El ajuste <literal>hit_set_count</literal> define el número de conjuntos de resultados que se están utilizando y <literal>hit_set_period</literal> define durante cuánto tiempo se ha utilizado cada conjunto. Cuando vence el periodo, se utiliza el siguiente conjunto de resultados. Si se agota el número de conjuntos de resultados, se libera la memoria del conjunto de resultados más antiguo y se crea un nuevo conjunto. Los valores de <literal>hit_set_count</literal> y <literal>hit_set_period</literal> multiplicados entre sí definen el marco de tiempo general durante el que se ha realizado el seguimiento del acceso a los objetos.
   </para>
   <figure xml:id="ses-tiered-hitset-overview-bloom">
    <title>Filtro de Bloom con 3 objetos almacenados</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="bloom-filter.svg" width="70%" format="SVG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="bloom-filter.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    En comparación con el número de objetos con hash, un conjunto de resultados a partir de un filtro de Bloom implica un uso muy eficaz de la memoria. Se necesitan menos de 10 bits para reducir la probabilidad de falsos positivos por debajo del 1 %. La probabilidad de falsos positivos se puede definir con <literal>hit_set_fpp</literal>. En función del número de objetos en un grupo de posiciones y la probabilidad de falsos positivos, Ceph calcula automáticamente el tamaño del conjunto de resultados.
   </para>
   <para>
    El almacenamiento requerido en el repositorio de caché se puede limitar con <literal>min_write_recency_for_promote</literal> y <literal>min_read_recency_for_promote</literal>. Si el valor se define como <literal>0</literal>, todos los objetos se almacenan en el repositorio de caché en cuanto se leen o se escriben y persisten hasta que son expulsados. Cualquier valor mayor que <literal>0</literal> define el número de conjuntos de resultados ordenados por antigüedad en los que se busca el objeto. Si el objeto se encuentra en un conjunto de resultados, se almacenará en el repositorio de caché.
   </para>
  </sect2>

  <sect2 xml:id="ses-tiered-hitset-examples">
   <title>Ejemplos</title>
   <sect3 xml:id="ses-tiered-hitset-examples-memory">
    <title>Repositorio de caché extenso y poca memoria</title>
    <para>
     Si hay mucho espacio de almacenamiento y poca cantidad de RAM disponible, se pueden almacenar todos los objetos en el repositorio de caché en cuanto se accede a ellos. El conjunto de resultados seguirá teniendo un tamaño pequeño. A continuación encontrará un conjunto de valores de configuración de ejemplo:
    </para>
<screen>hit_set_count = 1
hit_set_period = 3600
hit_set_fpp = 0.05
min_write_recency_for_promote = 0
min_read_recency_for_promote = 0</screen>
   </sect3>
   <sect3 xml:id="ses-tiered-hitset-examples-storage">
    <title>Repositorio de caché pequeño y mucha memoria</title>
    <para>
     Si hay poco espacio de almacenamiento, pero una capacidad de memoria disponible relativamente grande, el nivel de caché puede configurarse para que almacene un número limitado de objetos en el repositorio de caché. Doce conjuntos de resultados, de los cuales cada uno se usa durante un periodo de 14.400 segundos, proporcionan un seguimiento durante 48 horas en total. Si se ha accedido a un objeto durante las últimas 8 horas, se almacena en el repositorio de caché. El conjunto de valores de configuración de ejemplo es el siguiente:
    </para>
<screen>hit_set_count = 12
hit_set_period = 14400
hit_set_fpp = 0.01
min_write_recency_for_promote = 2
min_read_recency_for_promote = 2</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ses-tiered-storage">
  <title>Configuración de un ejemplo de niveles de almacenamiento</title>

  <para>
   En esta sección se muestra la configuración de un nivel de caché SSD rápido (almacenamiento en caliente) frente a un disco duro estándar (almacenamiento en frío).
  </para>

  <tip>
   <para>
    El ejemplo siguiente solo tiene fines ilustrativos e incluye una configuración con una raíz y una regla para la parte del SSD en un único nodo Ceph.
   </para>
   <para>
    En un entorno de producción, las configuraciones de clúster suelen incluir más raíces y reglas para el almacenamiento en caliente, así como nodos mixtos, con discos SSD y SATA.
   </para>
  </tip>

  <procedure>
   <step>
    <para>
     Prepare un equipo host con unidades rápidas, por ejemplo, SSD. Este nodo de clúster actuará como nivel de caché rápido.
    </para>
   </step>
   <step>
    <para>
     Convierta el equipo en un nodo Ceph mediante DeepSea. Instale el software y configure el equipo host como se describe en la <xref linkend="salt-adding-nodes"/>. Supongamos que su nombre es <replaceable>node-4</replaceable>. Este nodo debe tener 4 discos OSD.
    </para>
    <para>
     Esto puede dar lugar a una entrada similar a la siguiente en la asignación CRUSH:
    </para>
<screen>[...]
host node-4 {
   id -5  # do not change unnecessarily
   # weight 0.012
   alg straw
   hash 0  # rjenkins1
   item osd.6 weight 0.003
   item osd.7 weight 0.003
   item osd.8 weight 0.003
   item osd.9 weight 0.003
}
[...]</screen>
   </step>
   <step>
    <para>
     Edite la asignación CRUSH para el repositorio de almacenamiento en caliente asignado a los OSD con el respaldo de las unidades SSD rápidas. Defina una segunda jerarquía con un nodo raíz para los SSD (como "root ssd"). También puede cambiar el valor de peso (weight) y añadir una regla de CRUSH para los SSD. Para obtener más información sobre la asignación CRUSH, consulte <link xlink:href="http://docs.ceph.com/docs/master/rados/operations/crush-map/"/>.
    </para>
    <para>
     Edite la asignación CRUSH directamente con herramientas de línea de comandos, como <command>getcrushmap</command> y <command>crushtool</command>:
    </para>
    <substeps performance="required">
     <step>
      <para>
       Recupere la asignación actual y guárdela como <filename>c.map</filename>:
      </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd getcrushmap -o c.map</screen>
     </step>
     <step>
      <para>
       Descompile <filename>c.map</filename> y guárdelo como <filename>c.txt</filename>:
      </para>
<screen><prompt>cephadm &gt; </prompt>crushtool -d c.map -o c.txt</screen>
     </step>
     <step>
      <para>
       Edite <filename>c.txt</filename>:
      </para>
<screen>[...]
host node-4 {
        id -5  # do not change unnecessarily
        # weight 4.000
        alg straw
        hash 0  # rjenkins1
        item osd.6 weight 1.000
        item osd.7 weight 1.000
        item osd.8 weight 1.000
        item osd.9 weight 1.000
}
root ssd {    # newly added root for the SSD hot-storage
        id -6
        alg straw
        hash 0
        item node-4 weight 4.00
}
rule ssd {
        ruleset 4
        type replicated
        min_size 0
        max_size 4
        step take ssd
        step chooseleaf firstn 0 type host
        step emit
}
[...]</screen>
     </step>
     <step>
      <para>
       Compile el archivo <filename>c.txt</filename> editado y guárdelo como <filename>ssd.map</filename>:
      </para>
<screen><prompt>cephadm &gt; </prompt>crushtool -c c.txt -o ssd.map</screen>
     </step>
     <step>
      <para>
       Por último, instale <filename>ssd.map</filename> como la nueva asignación CRUSH:
      </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd setcrushmap -i ssd.map</screen>
     </step>
    </substeps>
   </step>
   <step>
    <para>
     Cree el repositorio de almacenamiento en caliente que se utilizará para los niveles de caché. Utilice la nueva regla "ssd":
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool create hot-storage 100 100 replicated ssd</screen>
   </step>
   <step>
    <para>
     Cree el repositorio de almacenamiento en frío con la regla "replicated_ruleset" por defecto:
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool create cold-storage 100 100 replicated replicated_ruleset</screen>
   </step>
   <step>
    <para>
     A continuación, la configuración de un nivel de caché implica asociar un repositorio de almacenamiento con un repositorio de caché, en este caso, almacenamiento en frío (copia de seguridad) con almacenamiento en caliente (caché):
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd tier add cold-storage hot-storage</screen>
   </step>
   <step>
    <para>
     Para definir el modo de caché como "writeback" (escritura diferida), realice lo siguiente:
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd tier cache-mode hot-storage writeback</screen>
    <para>
     Para obtener más información acerca de los modos de caché, consulte la <xref linkend="sec-ceph-tiered-cachemodes"/>.
    </para>
    <para>
     Los niveles de caché de la escritura diferida cubren el nivel de almacenamiento, por lo que requieren un paso adicional: debe dirigir todo el tráfico de los clientes del repositorio de almacenamiento al repositorio de caché. Para dirigir el tráfico de los clientes directamente al repositorio de caché, ejecute lo siguiente, por ejemplo:
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd tier set-overlay cold-storage hot-storage</screen>
   </step>
  </procedure>

  <sect2 xml:id="cache-tier-configure">
   <title>Configuración de un nivel de caché</title>
   <para>
    Existen varias opciones que puede utilizar para configurar niveles de caché. Utilice la siguiente sintaxis:
   </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> <replaceable>key</replaceable> <replaceable>value</replaceable></screen>
   <sect3>
    <title>Tipo y tamaño de destino</title>
    <para>
     En los pasos siguientes se describe cómo configurar un <emphasis>repositorio de caché</emphasis> con los valores descritos en la <xref linkend="ses-tiered-hitset-examples-storage"/>.
    </para>
    <para>
     Los niveles de caché de producción de Ceph emplean un filtro de Bloom para el parámetro <option>hit_set_type</option>:
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> hit_set_type bloom</screen>
    <para>
     Los parámetros <option>hit_set_count</option> y <option>hit_set_period</option> definen cuánto tiempo debe cubrir cada conjunto de resultados y cuántos de dichos conjuntos se deben almacenar. <remark role="fixme">What are the numbers doing? They're without explanation. https://software.intel.com/en-us/blogs/2015/03/03/ceph-cache-tiering-introduction</remark>
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> hit_set_count 12
<prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> hit_set_period 14400
<prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> target_max_bytes 1000000000000</screen>
    <note>
     <para>
      Un valor superior de <option>hit_set_count</option> da como resultado un mayor consumo de RAM por parte del proceso <systemitem class="process">ceph-osd</systemitem>.
     </para>
    </note>
    <para>
     El parámetro <option>min_read_recency_for_promote</option> define el número de conjuntos de resultados que hay que comprobar para verificar la existencia de un objeto al gestionar una operación de lectura. El resultado de la comprobación se utiliza para decidir si el objeto se debe almacenar de forma asíncrona. El valor debe estar entre 0 y el valor de <option>hit_set_count</option>. Si se define como 0, el objeto siempre se almacena. Si se define como 1, se comprueba el conjunto de resultados actual. Si el objeto se encuentra en el conjunto de resultados, se almacena. De lo contrario, no se almacena. Para los demás valores, se comprueba el número exacto de conjuntos de resultados. El objeto se almacena si se encuentra en cualquiera de los conjuntos de resultados recientes de <option>min_read_recency_for_promote</option>.
    </para>
    <para>
     Puede definir un parámetro similar, <option>min_write_recency_for_promote</option>, para la operación de escritura:
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> min_read_recency_for_promote 2
<prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> min_write_recency_for_promote 2</screen>
    <note>
     <para>
      Cuanto más prolongado sea el periodo y más altos los valores de <option>min_read_recency_for_promote</option> y <option>min_write_recency_for_promote</option>, más memoria RAM consumirá el daemon <systemitem class="process">ceph-osd</systemitem>. En concreto, cuando el agente se activa para limpiar o expulsar objetos del caché, todos los conjuntos de resultados de <option>hit_set_count</option> se cargan en la memoria RAM.
     </para>
    </note>
   </sect3>
   <sect3>
    <title>Tamaño de caché</title>
    <para>
     El agente de niveles de caché realiza dos funciones principales:
    </para>
    <variablelist>
     <varlistentry>
      <term>Limpieza</term>
      <listitem>
       <para>
        El agente identifica objetos modificados (sucios) y los envía al repositorio de almacenamiento para el almacenamiento a largo plazo.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Expulsión</term>
      <listitem>
       <para>
        El agente identifica los objetos que no han sido modificados (limpios) y expulsa del caché a los que no se han utilizado recientemente.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <sect4 xml:id="cache-tier-config-absizing">
     <title>Tamaño absoluto</title>
     <para>
      El agente de niveles de caché puede limpiar o expulsar objetos basándose en el número total de bytes o en el número total de objetos. Para especificar un número máximo de bytes, ejecute lo siguiente:
     </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> target_max_bytes <replaceable>num_of_bytes</replaceable></screen>
     <para>
      Para especificar el número máximo de objetos, ejecute lo siguiente:
     </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> target_max_objects <replaceable>num_of_objects</replaceable></screen>
     <note>
      <para>
       Ceph no puede determinar el tamaño de un repositorio de caché de forma automática, por lo que se precisa la configuración del tamaño absoluto. De lo contrario, las tareas de limpieza y expulsión no funcionarán. Si especifica ambos límites, el agente de niveles de caché empezará a limpiar o a expulsar cuando se active cualquiera de los dos umbrales.
      </para>
     </note>
     <note>
      <para>
       Solo se bloquearán todas las peticiones de los clientes cuando se alcancen los valores de <option>target_max_bytes</option> o <option>target_max_objects</option>.
      </para>
     </note>
    </sect4>
    <sect4 xml:id="cache-tier-config-relsizing">
     <title>Tamaño relativo</title>
     <para>
      El agente de niveles de caché puede limpiar o expulsar objetos en relación al tamaño del repositorio de caché (especificado por <option>target_max_bytes</option> o <option>target_max_objects</option> en la <xref linkend="cache-tier-config-absizing"/>). Cuando el repositorio de caché conste de determinado porcentaje de objetos modificados (sucios), el agente de niveles de caché los limpiará vaciándolos en el repositorio de almacenamiento. Para definir el valor de <option>cache_target_dirty_ratio</option>, ejecute lo siguiente:
     </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> cache_target_dirty_ratio <replaceable>0.0...1.0</replaceable></screen>
     <para>
      Por ejemplo, si define el valor como 0,4, la limpieza de los objetos modificados (sucios) comenzará cuando se alcance el 40 % de la capacidad del repositorio de caché:
     </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set hot-storage cache_target_dirty_ratio 0.4</screen>
     <para>
      Cuando los objetos sucios alcancen un porcentaje determinado de la capacidad, se limpiarán a una velocidad superior. Use <option>cache_target_dirty_high_ratio</option>:
     </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> cache_target_dirty_high_ratio <replaceable>0.0..1.0</replaceable></screen>
     <para>
      Cuando el repositorio de caché alcance un porcentaje determinado de su capacidad, el agente de niveles de caché expulsará objetos para mantener la capacidad disponible. Para definir el valor de <option>cache_target_full_ratio</option>, ejecute lo siguiente:
     </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> cache_target_full_ratio <replaceable>0.0..1.0</replaceable></screen>
    </sect4>
   </sect3>
   <sect3>
    <title>Antigüedad del caché</title>
    <para>
     Puede especificar la antigüedad mínima que debe tener un objeto (sucio) modificado recientemente para que el agente de niveles de caché lo vacíe en el repositorio de almacenamiento:
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> cache_min_flush_age <replaceable>num_of_seconds</replaceable></screen>
    <para>
     Puede especificar la antigüedad mínima que debe tener un objeto para que se expulse del nivel de caché:
    </para>
<screen><prompt>cephadm &gt; </prompt>sudo ceph osd pool set <replaceable>cachepool</replaceable> cache_min_evict_age <replaceable>num_of_seconds</replaceable></screen>
   </sect3>
   <sect3 xml:id="ceph-tier-gmt-hitset">
    <title>Utilice GMT para el conjunto de resultados</title>
    <para>
     Las configuraciones de nivel de caché tienen un filtro de Bloom llamado <emphasis>conjunto de resultados.</emphasis> El filtro comprueba si un objeto pertenece a un conjunto de objetos de almacenamiento en frío o en caliente. Los objetos se incorporan al conjunto de resultados con marcas horarias añadidas a su nombre.
    </para>
    <para>
     Si los equipos del clúster se encuentran en distintas zonas horarias y las marcas horarias se corresponden con la hora local, los objetos de un conjunto de resultados pueden tener nombres equívocos, con marcas horarias futuras o pasadas. En el peor de los casos, los objetos podrían no existir en el conjunto de resultados.
    </para>
    <para>
     Para evitar esto, el parámetro <option>use_gmt_hitset</option> tiene un valor por defecto de "1" en las configuraciones de nivel de caché recién creadas. De este modo, se fuerza el uso de marcas horarias GMT (hora del meridiano de Greenwich) por parte de los OSD al crear los nombres de objetos para los conjuntos de resultados.
    </para>
    <warning>
     <title>deje el valor por defecto</title>
     <para>
      No modifique el valor por defecto de "1" en <option>use_gmt_hitset</option>. Si los errores relacionados con esta opción no se deben a la configuración del clúster, no lo cambie nunca manualmente. De lo contrario, el comportamiento del clúster podría ser impredecible.
     </para>
    </warning>
   </sect3>
  </sect2>
 </sect1>
</chapter>

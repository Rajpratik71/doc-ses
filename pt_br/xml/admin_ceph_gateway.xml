<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_ceph_gateway.xml" version="5.0" xml:id="cha-ceph-gw">

 <title>Ceph Object Gateway</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:maintainer>tbazant@suse.com</dm:maintainer>
        <dm:status>editando</dm:status>
        <dm:deadline/>
        <dm:priority/>
        <dm:translation>yes (sim)</dm:translation>
        <dm:languages/>
        <dm:release>SES 5</dm:release>
      </dm:docmanager>
    </info>
    <para>
  Este capítulo apresenta detalhes sobre as tarefas de administração relacionadas ao Object Gateway, como verificação de status do serviço, gerenciamento de contas, gateways multissite ou autenticação LDAP.
 </para>
 <sect1 xml:id="sec-ceph-rgw-limits">
  <title>Restrições e limitações de nomeação do Object Gateway</title>

  <para>
   Veja a seguir uma lista dos limites importantes do Object Gateway:
  </para>

  <sect2 xml:id="ogw-limits-bucket">
   <title>Limitações de compartimento de memória</title>
   <para>
    Ao usar o Object Gateway por meio da API do S3, há um limite para os nomes de compartimento de memória que devem ser compatíveis com DNS e podem ter um traço “-”. Ao usar o Object Gateway por meio da API do Swift, você pode aplicar qualquer combinação de caracteres UTF-8 permitidos, exceto a barra “/”. O tamanho máximo do nome de um compartimento de memória é de 255 caracteres. Os nomes de compartimento de memória devem ser exclusivos.
   </para>
   <tip>
    <title>Usar nomes de compartimento de memória compatíveis com DNS</title>
    <para>
     Embora seja possível usar qualquer nome de compartimento de memória baseado em UTF-8 por meio da API do Swift, é recomendável nomear os compartimentos de memória de acordo com as limitações de nomeação do S3 para evitar problemas ao acessar o mesmo compartimento de memória pela API do S3.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ogw-limits-object">
   <title>Limitações de objetos armazenados</title>
   <variablelist>
    <varlistentry>
     <term>Número máximo de objetos por usuário</term>
     <listitem>
      <para>
       Por padrão, nenhuma restrição (limitado por ~ 2^63).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Número máximo de objetos por compartimento de memória</term>
     <listitem>
      <para>
       Por padrão, nenhuma restrição (limitado por ~ 2^63).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Tamanho máximo de um objeto para upload/armazenamento</term>
     <listitem>
      <para>
       Cada upload está restrito a 5 GB. Use várias partes para tamanhos de objetos maiores. O número máximo de pacotes de várias partes é 10.000.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ogw-limits-http">
   <title>Limitações de cabeçalho HTTP</title>
   <para>
    A limitação de cabeçalho HTTP e de solicitação depende do front end da Web usado. O CivetWeb padrão restringe o número de cabeçalhos HTTP a 64 e o tamanho a 16 KB cada.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-deploy">
  <title>Implantando o Object Gateway</title>

  <para>
   O método recomendado de implantar o Ceph Object Gateway é pela infraestrutura do DeepSea, adicionando a(s) linha(s) <literal>role-rgw [...]</literal> relevante(s) ao arquivo <filename>policy.cfg</filename> no master Salt e executando as fases necessárias do DeepSea.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Para incluir o Object Gateway durante o processo de implantação do cluster do Ceph, consulte o <xref linkend="ceph-install-stack"/> e o <xref linkend="policy-configuration"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     Para adicionar a função Object Gateway a um cluster já implantado, consulte a <xref linkend="salt-adding-services"/>.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="ceph-rgw-operating">
  <title>Operando o serviço Object Gateway</title>

  <para>
   O serviço Object Gateway é operado pelo comando <command>systemctl</command>. Você precisa ter privilégios de <systemitem class="username">root</systemitem> para operar o serviço Object Gateway. Observe que <replaceable>gateway_host</replaceable> é o nome de host do servidor cuja instância do Object Gateway você precisa operar.
  </para>

  <para>
   Os subcomandos a seguir são suportados para o serviço Object Gateway:
  </para>

  <variablelist>
   <varlistentry>
    <term>systemctl status ceph-radosgw@rgw.<replaceable>gateway_host</replaceable>
    </term>
    <listitem>
     <para>
      Imprime as informações de status do serviço
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl start ceph-radosgw@rgw.<replaceable>gateway_host</replaceable>
    </term>
    <listitem>
     <para>
      Inicia o serviço caso ainda não esteja em execução.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl restart ceph-radosgw@rgw.<replaceable>gateway_host</replaceable>
    </term>
    <listitem>
     <para>
      Reinicia o serviço.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl stop ceph-radosgw@rgw.<replaceable>gateway_host</replaceable>
    </term>
    <listitem>
     <para>
      Para o serviço em execução.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl enable ceph-radosgw@rgw.<replaceable>gateway_host</replaceable>
    </term>
    <listitem>
     <para>
      Habilita o serviço para que ele seja iniciado automaticamente na inicialização do sistema.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl disable ceph-radosgw@rgw.<replaceable>gateway_host</replaceable>
    </term>
    <listitem>
     <para>
      Desabilita o serviço para que ele não seja iniciado automaticamente na inicialização do sistema.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-ceph-rgw-configuration">
  <title>Parâmetros de configuração</title>

  <para>
   O comportamento do Object Gateway pode ser afetado por inúmeras opções no arquivo <filename>ceph.conf</filename>. Veja a seguir uma lista das mais importantes. Para ver a lista completa, consulte <link xlink:href="http://docs.ceph.com/docs/master/radosgw/config-ref/"/>.
  </para>

  <variablelist>
   <varlistentry>
    <term>rgw_thread_pool_size</term>
    <listitem>
     <para>
      Número de threads para o servidor CivetWeb. Aumente para um valor mais alto se você precisa atender a mais solicitações. O padrão é 100 threads.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>rgw_num_rados_handles</term>
    <listitem>
     <para>
      O número de manipuladores de cluster RADOS (consulte <link xlink:href="http://docs.ceph.com/docs/master/rados/api/librados-intro/#step-2-configuring-a-cluster-handle"/>) para o Object Gateway. Disponibilizar um número configurável de manipuladores RADOS tem resultado em um aumento significativo no desempenho para todos os tipos de cargas de trabalho. Agora, cada thread do worker do Object Gateway precisa selecionar um manipulador RADOS para sua vida útil. O padrão é 1.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>rgw_max_chunk_size</term>
    <listitem>
     <para>
      Tamanho máximo de um pacote de dados que será lido em uma única operação. Aumentar o valor para 4 MB (4194304) proporcionará um melhor desempenho ao processar objetos grandes. O padrão é 128 KB (131072).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="sec-ceph-rgw-configuration-notes">
   <title>Notas adicionais</title>
   <variablelist>
    <varlistentry>
     <term>rgw dns name</term>
     <listitem>
      <para>
       Se o parâmetro <literal>rgw dns name</literal> for adicionado a <filename>ceph.conf</filename>, verifique se o cliente S3 foi configurado para direcionar as solicitações no endpoint especificado por <literal>rgw dns name</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-access">
  <title>Gerenciando o acesso ao Object Gateway</title>

  <para>
   Você pode se comunicar com o Object Gateway usando qualquer interface compatível com S3 ou Swift. A interface do S3 é compatível com um grande subconjunto da API RESTful do Amazon S3. A interface do Swift é compatível com um grande subconjunto da API do OpenStack Swift.
  </para>

  <para>
   As duas interfaces exigem que você crie um usuário específico e instale o software cliente relevante para comunicação com o gateway usando a chave secreta do usuário.
  </para>

  <sect2 xml:id="accessing-ragos-gateway">
   <title>Acessando o Object Gateway</title>
   <sect3>
    <title>Acesso à interface do S3</title>
    <para>
     Para acessar a interface do S3, você precisa de um cliente REST. <command>S3cmd</command> é um cliente S3 de linha de comando. Você pode encontrá-lo em <link xlink:href="https://build.opensuse.org/package/show/Cloud:Tools/s3cmd">OpenSUSE Build Service</link>. O repositório contém as versões para ambas as distribuições baseadas no SUSE Linux Enterprise e no openSUSE.
    </para>
    <para>
     Para testar o acesso à interface do S3, você também pode gravar um pequeno script do Python. O script se conectará ao Object Gateway, criará um novo compartimento de memória e listará todos os compartimentos de memória. Os valores para <option>aws_access_key_id</option> e <option>aws_secret_access_key</option> são extraídos dos valores de <option>access_key</option> e <option>secret_key</option> retornados pelo comando <command>radosgw_admin</command> da <xref linkend="adding-s3-swift-users"/>.
    </para>
    <procedure>
     <step>
      <para>
       Instale o pacote <systemitem>python-boto</systemitem>:
      </para>
<screen>sudo zypper in python-boto</screen>
     </step>
     <step>
      <para>
       Crie um novo script do Python denominado <filename>s3test.py</filename> com o seguinte conteúdo: <remark role="fixme">Provide script in RPM? Is it really necessary to create pool? This script is not necessary at all, remove it from documentation?</remark>
      </para>
<screen>import boto
import boto.s3.connection
access_key = '11BS02LGFB6AL6H1ADMW'
secret_key = 'vzCEkuryfn060dfee4fgQPqFrncKEIkh3ZcdOANY'
conn = boto.connect_s3(
aws_access_key_id = access_key,
aws_secret_access_key = secret_key,
host = '{hostname}',
is_secure=False,
calling_format = boto.s3.connection.OrdinaryCallingFormat(),
)
bucket = conn.create_bucket('my-new-bucket')
for bucket in conn.get_all_buckets():
  print "{name}\t{created}".format(
  name = bucket.name,
  created = bucket.creation_date,
  )</screen>
      <para>
       Substitua <literal>{hostname}</literal> pelo nome de host no qual você configurou o serviço Object Gateway. Por exemplo, <literal>gateway_host</literal>.
      </para>
     </step>
     <step>
      <para>
       Execute o script:
      </para>
<screen>python s3test.py</screen>
      <para>
       A saída do script é parecida com o seguinte:
      </para>
<screen>my-new-bucket 2015-07-22T15:37:42.000Z</screen>
     </step>
    </procedure>
   </sect3>
   <sect3>
    <title>Acesso à interface do Swift</title>
    <para>
     Para acessar o Object Gateway pela interface do Swift, você precisa do cliente de linha de comando <command>swift</command>. A página de manual dele <command>man 1 swift</command> apresenta mais detalhes sobre as opções de linha de comando.
    </para>
    <para>
     O pacote está incluído no módulo “Public Cloud” (Nuvem Pública) do SUSE Linux Enterprise 12 SP3. Antes de instalar o pacote, você precisa ativar o módulo e atualizar o repositório de software:
    </para>
<screen>sudo SUSEConnect -p sle-module-public-cloud/12/x86_64
sudo zypper refresh</screen>
    <para>
     Para instalar o comando <command>swift</command>, execute o seguinte:
    </para>
<screen>sudo zypper in python-swiftclient</screen>
    <para>
     O acesso ao swift usa a seguinte sintaxe:
    </para>
<screen>swift -A http://<replaceable>IP_ADDRESS</replaceable>/auth/1.0 \
-U example_user:swift -K '<replaceable>swift_secret_key</replaceable>' list</screen>
    <para>
     Substitua <replaceable>IP_ADDRESS</replaceable> pelo endereço IP do servidor gateway, e <replaceable>swift_secret_key</replaceable> pelo respectivo valor da saída do comando <command>radosgw-admin key create</command> executado para o usuário <systemitem>swift</systemitem> na <xref linkend="adding-s3-swift-users"/>.
    </para>
    <para>
     Por exemplo:
    </para>
<screen>swift -A http://gateway.example.com/auth/1.0 -U example_user:swift \
-K 'r5wWIxjOCeEO7DixD1FjTLmNYIViaC6JVhi3013h' list</screen>
    <para>
     A saída é:
    </para>
<screen>my-new-bucket</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="s3-swift-accounts-managment">
   <title>Gerenciando contas do S3 e do Swift</title>
   <sect3 xml:id="adding-s3-swift-users">
    <title>Adicionando usuários do S3 e do Swift</title>
    <para>
     É necessário criar um usuário, uma chave de acesso e um segredo para permitir que os usuários finais interajam com o gateway. Há dois tipos de usuário: <emphasis>usuário</emphasis> e <emphasis>subusuário</emphasis>. Os <emphasis>usuários</emphasis> são usados para interagir com a interface do S3, os <emphasis>subusuários</emphasis> são usuáros da interface do Swift. Cada subusuário está associado a um usuário.
    </para>
    <para>
     Os usuários também podem ser adicionados por meio do arquivo <filename>rgw.sls</filename> do DeepSea. Para obter um exemplo, consulte a <xref linkend="ceph-nfsganesha-customrole-rgw-multiusers"/>.
    </para>
    <para>
     Para criar um usuário do Swift, siga as etapas:
    </para>
    <procedure>
     <step>
      <para>
       Para criar um usuário do Swift, que é um <emphasis>subusuário</emphasis> em nossa terminologia, você precisa criar primeiro o <emphasis>usuário</emphasis> associado.
      </para>
<screen>sudo radosgw-admin user create --uid=<replaceable>username</replaceable> \
 --display-name="<replaceable>display-name</replaceable>" --email=<replaceable>email</replaceable></screen>
      <para>
       Por exemplo:
      </para>
<screen>sudo radosgw-admin user create \
   --uid=example_user \
   --display-name="Example User" \
   --email=penguin@example.com</screen>
     </step>
     <step>
      <para>
       Para criar um subusuário (interface do Swift) para o usuário, você deve especificar o ID de usuário (--uid=<replaceable>nomedeusuário</replaceable>), um ID de subusuário e o nível de acesso para o subusuário.
      </para>
<screen>sudo radosgw-admin subuser create --uid=<replaceable>uid</replaceable> \
 --subuser=<replaceable>uid</replaceable> \
 --access=[ <replaceable>read | write | readwrite | full</replaceable> ]</screen>
      <para>
       Por exemplo:
      </para>
<screen>sudo radosgw-admin subuser create --uid=example_user \
 --subuser=example_user:swift --access=full</screen>
     </step>
     <step>
      <para>
       Gere uma chave secreta para o usuário.
      </para>
<screen>sudo radosgw-admin key create \
   --gen-secret \
   --subuser=example_user:swift \
   --key-type=swift</screen>
     </step>
     <step>
      <para>
       Os dois comandos resultarão em dados formatados em JSON que mostram o estado do usuário. Observe as linhas a seguir e lembre-se do valor <literal>secret_key</literal>:
      </para>
<screen>"swift_keys": [
   { "user": "example_user:swift",
     "secret_key": "r5wWIxjOCeEO7DixD1FjTLmNYIViaC6JVhi3013h"}],</screen>
     </step>
    </procedure>
    <para/>
    <para>
     Ao acessar o Object Gateway por meio da interface do S3, você precisa criar um usuário do S3 executando:
    </para>
<screen>sudo radosgw-admin user create --uid=<replaceable>username</replaceable> \
 --display-name="<replaceable>display-name</replaceable>" --email=<replaceable>email</replaceable></screen>
    <para>
     Por exemplo:
    </para>
<screen>sudo radosgw-admin user create \
   --uid=example_user \
   --display-name="Example User" \
   --email=penguin@example.com</screen>
    <para>
     O comando também cria o acesso do usuário e a chave secreta. Verifique a saída para as palavras-chave <literal>access_key</literal> e <literal>secret_key</literal> e seus valores:
    </para>
<screen>[...]
 "keys": [
       { "user": "example_user",
         "access_key": "11BS02LGFB6AL6H1ADMW",
         "secret_key": "vzCEkuryfn060dfee4fgQPqFrncKEIkh3ZcdOANY"}],
 [...]</screen>
   </sect3>
   <sect3 xml:id="removing-s3-swift-users">
    <title>Removendo usuários do S3 e do Swift</title>
    <para>
     O procedimento para apagar usuários é semelhante para os usuários do S3 e do Swift. No caso dos usuários do Swift, porém, você pode precisar apagar o usuário com os subusuários incluídos.
    </para>
    <para>
     Para remover um usuário do S3 ou do Swift (incluindo todos os subusuários), especifique <option>user rm</option> e o ID de usuário no seguinte comando:
    </para>
<screen>sudo radosgw-admin user rm --uid=example_user</screen>
    <para>
     Para remover um subusuário, especifique <option>subuser rm</option> e o ID de subusuário.
    </para>
<screen>sudo radosgw-admin subuser rm --uid=example_user:swift</screen>
    <para>
     Você pode usar as seguintes opções:
    </para>
    <variablelist>
     <varlistentry>
      <term>--purge-data</term>
      <listitem>
       <para>
        Purga todos os dados associados ao ID de usuário.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--purge-keys</term>
      <listitem>
       <para>
        Purga todas as chaves associadas ao ID de usuário.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <tip>
     <title>Removendo um subusuário</title>
     <para>
      Ao remover um subusuário, você remove o acesso à interface do Swift. O usuário permanecerá no sistema.
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="changing-s3-swift-users-password">
    <title>Mudando o acesso e as chaves secretas do usuário do S3 e do Swift</title>
    <para>
     Os parâmetros <literal>access_key</literal> e <literal>secret_key</literal> identificam o usuário do Object Gateway ao acessar o gateway. A mudança das chaves existentes de usuário é o mesmo que criar novas chaves, pois as chaves antigas são sobregravadas.
    </para>
    <para>
     Para usuários do S3, execute o seguinte:
    </para>
<screen>sudo radosgw-admin key create --uid=<replaceable>example_user</replaceable> --key-type=s3 --gen-access-key --gen-secret</screen>
    <para>
     Para usuários do Swift, execute o seguinte:
    </para>
<screen>sudo radosgw-admin key create --subuser=<replaceable>example_user</replaceable>:swift --key-type=swift --gen-secret</screen>
    <variablelist>
     <varlistentry>
      <term><option>--key-type=<replaceable>type</replaceable></option>
      </term>
      <listitem>
       <para>
        Especifica o tipo de chave. Pode ser <literal>swift</literal> ou <literal>s3</literal>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--gen-access-key</option>
      </term>
      <listitem>
       <para>
        Gera uma chave de acesso aleatória (por padrão, para o usuário do S3).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--gen-secret</option>
      </term>
      <listitem>
       <para>
        Gera uma chave secreta aleatória.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--secret=<replaceable>key</replaceable></option>
      </term>
      <listitem>
       <para>
        Especifica uma chave secreta. Por exemplo, gerada manualmente.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="user-quota-managment">
    <title>Gerenciamento de cotas de usuário</title>
    <para>
     O Ceph Object Gateway permite definir cotas para usuários e compartimentos de memória pertencentes aos usuários. As cotas incluem o número máximo de objetos em um compartimento de memória e o tamanho máximo de armazenamento em megabytes.
    </para>
    <para>
     Antes de habilitar uma cota de usuário, você precisa definir os respectivos parâmetros:
    </para>
<screen>sudo radosgw-admin quota set --quota-scope=user --uid=<replaceable>example_user</replaceable> \
 --max-objects=1024 --max-size=1024</screen>
    <variablelist>
     <varlistentry>
      <term><option>--max-objects</option>
      </term>
      <listitem>
       <para>
        Especifica o número máximo de objetos. Um valor negativo desabilita a verificação.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--max-size</option>
      </term>
      <listitem>
       <para>
        Especifica o número máximo de bytes. Um valor negativo desabilita a verificação.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--quota-scope</option>
      </term>
      <listitem>
       <para>
        Define o escopo para a cota. As opções são <literal>bucket</literal> e <literal>user</literal>. As cotas de compartimento de memória aplicam-se aos compartimentos de memória que um usuário possui. As cotas de usuário aplicam-se a um usuário.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Após definir uma cota de usuário, você poderá habilitá-la:
    </para>
<screen>sudo radosgw-admin quota enable --quota-scope=user --uid=<replaceable>example_user</replaceable></screen>
    <para>
     Para desabilitar uma cota:
    </para>
<screen>sudo radosgw-admin quota disable --quota-scope=user --uid=<replaceable>example_user</replaceable></screen>
    <para>
     Para listar as configurações de cota:
    </para>
<screen>sudo radosgw-admin user info --uid=<replaceable>example_user</replaceable></screen>
    <para>
     Para atualizar as estatísticas de cota:
    </para>
<screen>sudo radosgw-admin user stats --uid=<replaceable>example_user</replaceable> --sync-stats</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-https">
  <title>Habilitando HTTPS/SSL para Object Gateways</title>

  <para>
   Para habilitar a função Object Gateway padrão para comunicação segura por meio de SSL, você precisa ter um certificado emitido por uma CA ou criar um autoassinado. Há duas maneiras de configurar o Object Gateway com HTTPS habilitado: uma maneira simples que usa as configurações padrão e uma maneira avançada que permite ajustar as configurações relacionadas a HTTPS.
  </para>

  <sect2 xml:id="ogw-selfcert">
   <title>Criar um certificado autoassinado</title>
   <tip>
    <para>
     Ignore esta seção se você já tem um certificado válido assinado por uma CA.
    </para>
   </tip>
   <para>
    Por padrão, o DeepSea espera o arquivo de certificado em <filename>/srv/salt/ceph/rgw/cert/rgw.pem</filename> no master Salt. Em seguida, ele distribuirá o certificado para <filename>/etc/ceph/rgw.pem</filename> no minion Salt com a função Object Gateway, onde o Ceph faz a leitura.
   </para>
   <para>
    O procedimento a seguir descreve como gerar um certificado SSL autoassinado no nó master Salt.
   </para>
   <procedure>
    <step>
     <para>
      Adicione a opção <option>subjectAltName</option> à seção <literal>[v3_req]</literal> do arquivo <filename>/etc/ssl/openssl.cnf</filename> para todos os nomes de host desejados para o seu Object Gateway:
     </para>
<screen>
[...]
[ v3_req ]
subjectAltName = ${ENV::SAN}
[...]
</screen>
    </step>
    <step>
     <para>
      Crie a chave e o certificado usando <command>openssl</command>. Adicione o prefixo <literal>env SAN=DNS:fqdn</literal> ao <command>openssl</command>. Insira todos os dados que você precisa incluir em seu certificado. É recomendável inserir o FQDN como nome comum. Antes de assinar o certificado, verifique se “X509v3 Subject Alternative Name:” está incluído nas extensões solicitadas e se o certificado resultante tem "X509v3 Subject Alternative Name:" definido.
     </para>
<screen>
<prompt>root@master # </prompt>env SAN=DNS:fqdn openssl req -x509 -nodes -days 1095 \
 -newkey rsa:4096 -keyout rgw.key -out /srv/salt/ceph/rgw/cert/rgw.pem
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-ssl-simple">
   <title>Configuração de HTTPS simples</title>
   <para>
    Por padrão, o Ceph no nó do Object Gateway lê o cerificado <filename>/etc/ceph/rgw.pem</filename> e usa a porta 443 para comunicação SSL segura. Se você não precisa mudar esses valores, siga estas etapas:
   </para>
   <procedure>
    <step>
     <para>
      Edite <filename>/srv/pillar/ceph/stack/global.yml</filename> e adicione a seguinte linha:
     </para>
<screen>
rgw_configurations: rgw-ssl
rgw_init: default-ssl
</screen>
    </step>
    <step>
     <para>
      Execute as Fases 2, 3 e 4 do DeepSea para aplicar as mudanças:
     </para>
<screen>
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.2
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.3
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.4
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-ssl-advanced">
   <title>Configuração de HTTPS avançada</title>
   <para>
    Se você precisar mudar os valores padrão para as configurações de SSL do Object Gateway, siga estas etapas:
   </para>
   <procedure>
    <step>
     <para>
      Copie a configuração de SSL do Object Gateway padrão para o subdiretório <filename>ceph.conf.d</filename>:
     </para>
<screen>
<prompt>root@master # </prompt>cp /srv/salt/ceph/configuration/files/rgw-ssl.conf \
 /srv/salt/ceph/configuration/files/ceph.conf.d/rgw.conf
</screen>
    </step>
    <step>
     <para>
      Edite <filename>/srv/salt/ceph/configuration/files/ceph.conf.d/rgw.conf</filename> e mude as opções padrão, como número da porte ou caminho para o certificado SSL, para refletir sua configuração.
     </para>
    </step>
    <step>
     <para>
      Execute as Fases 3 e 4 do DeepSea para aplicar as mudanças:
     </para>
<screen>
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.3
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.4
</screen>
    </step>
   </procedure>
   <tip xml:id="rgw-civetweb-multiport">
    <title>Vinculando a várias portas</title>
    <para>
     O servidor CivetWeb pode ser vinculado a várias portas. Isso será útil se você precisar acessar uma única instância do Object Gateway com ambas as conexões SSL e não SSL. Ao especificar as portas, separe os números usando um sinal de adição “+”. Veja a seguir um exemplo de linha de configuração de duas portas:
    </para>
<screen>[client.{{ client }}]
rgw_frontends = civetweb port=80+443s ssl_certificate=/etc/ceph/rgw.pem</screen>
   </tip>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-sync">
  <title>Módulos de sincronização</title>

  <para>
   A funcionalidade <emphasis>multissite</emphasis> do Object Gateway incluída no Jewel permite criar várias zonas e espelhar os dados e metadados entre elas. Os <emphasis>Módulos de Sincronização</emphasis> foram desenvolvidos com base na estrutura multissite, que permite encaminhar dados e metadados para uma camada externa diferente. Um módulo de sincronização permite a execução de um conjunto de ações sempre que há uma mudança nos dados (operações de metadados, como criação de compartimento de memória ou usuário, etc., também são consideradas mudanças nos dados). Como as mudanças multissite do rgw acabam sendo consistentes em sites remotos, elas são propagadas de forma assíncrona. Desse modo, é possível desbloquear casos de uso, como backup de armazenamento de objetos em um cluster de nuvem externo ou em uma solução de backup personalizada que usa unidades de fita, indexação de metadados no Elasticsearch, etc.
  </para>

  <sect2 xml:id="ceph-rgw-sync-zones">
   <title>Sincronizando zonas</title>
   <para>
    A configuração de um módulo de sincronização é local para uma zona. O módulo de sincronização determina se a zona exporta os dados ou apenas pode consumir os dados que foram modificados em outra zona. A partir do Luminous, os plug-ins de sincronização suportados são <literal>elasticsearch</literal>, <literal>rgw</literal>, que é o padrão para sincronizar dados entre zonas, e <literal>log</literal>, que é o comum para registrar a operação de metadados que ocorre nas zonas remotas. As seções a seguir foram elaboradas com o exemplo de uma zona que usa o módulo de sincronização <literal>elasticsearch</literal>. O mesmo processo pode ser aplicado para configurar qualquer outro plug-in de sincronização.
   </para>
   <note>
    <title>Plug-in de sincronização padrão</title>
    <para>
     <literal>rgw</literal> é o plug-in de sincronização padrão, e não há necessidade de configurá-lo explicitamente.
    </para>
   </note>
   <sect3 xml:id="ceph-rgw-sync-zones-req">
    <title>Requisitos e considerações</title>
    <para>
     Vamos considerar uma configuração multissite simples, conforme descrito na <xref linkend="ceph-rgw-fed"/>, com 2 zonas <literal>us-east</literal> e <literal>us-west</literal>. Agora, adicionamos uma terceira zona <literal>us-east-es</literal>, que processará apenas os metadados de outros sites. Essa zona pode estar no mesmo ou em um cluster do Ceph diferente do <literal>us-east</literal>. Essa zona consumirá apenas os metadados de outras zonas, e os Object Gateways nela não atenderão diretamente nenhuma solicitação de usuário final.
    </para>
   </sect3>
   <sect3 xml:id="ceph-rgw-sync-zones-configure">
    <title>Configurando módulos de sincronização</title>
    <procedure>
     <step>
      <para>
       Crie a terceira zona semelhante àquelas descritas na <xref linkend="ceph-rgw-fed"/>. Por exemplo,
      </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> zone create --rgw-zonegroup=us --rgw-zone=us-east-es \
--access-key={system-key} --secret={secret} --endpoints=http://rgw-es:80
      </screen>
     </step>
     <step>
      <para>
       É possível configurar um módulo de sincronização para essa zona por meio do seguinte procedimento
      </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> zone modify --rgw-zone={zone-name} --tier-type={tier-type} \
--tier-config={set of key=value pairs}
      </screen>
     </step>
     <step>
      <para>
       Por exemplo, no módulo de sincronização <literal>elasticsearch</literal>
      </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> zone modify --rgw-zone={zone-name} --tier-type=elasticsearch \
--tier-config=endpoint=http://localhost:9200,num_shards=10,num_replicas=1
      </screen>
      <para>
       Para as várias opções de configuração de camada suportadas, consulte a <xref linkend="ceph-rgw-sync-elastic"/>.
      </para>
     </step>
     <step>
      <para>
       Por fim, atualize o período
      </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> period update --commit
      </screen>
     </step>
     <step>
      <para>
       Agora, inicie o radosgw na zona
      </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> start ceph-radosgw@rgw.`hostname -s`
<prompt>root # </prompt><command>systemctl</command> enable ceph-radosgw@rgw.`hostname -s`
      </screen>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-sync-elastic">
   <title>Armazenando metadados no Elasticsearch</title>
   <para>
    Este módulo de sincronização grava os metadados de outras zonas no Elasticsearch. A partir do Luminous, é o JSON dos campos de dados que armazenamos no Elasticsearch.
   </para>
<screen>
{
  "_index" : "rgw-gold-ee5863d6",
  "_type" : "object",
  "_id" : "34137443-8592-48d9-8ca7-160255d52ade.34137.1:object1:null",
  "_score" : 1.0,
  "_source" : {
    "bucket" : "testbucket123",
    "name" : "object1",
    "instance" : "null",
    "versioned_epoch" : 0,
    "owner" : {
      "id" : "user1",
      "display_name" : "user1"
    },
    "permissions" : [
      "user1"
    ],
    "meta" : {
      "size" : 712354,
      "mtime" : "2017-05-04T12:54:16.462Z",
      "etag" : "7ac66c0f148de9519b8bd264312c4d64"
    }
  }
}
   </screen>
   <sect3 xml:id="ceph-rgw-sync-elastic-config">
    <title>Parâmetros de configuração de tipo de camada do Elasticsearch</title>
    <variablelist>
     <varlistentry>
      <term>endpoint</term>
      <listitem>
       <para>
        Especifica o endpoint do servidor Elasticsearch a ser acessado.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>num_shards</term>
      <listitem>
       <para>
        <emphasis>(número inteiro)</emphasis> O número de fragmentos que será configurado no Elasticsearch na inicialização da sincronização de dados. Observe que ele não pode ser mudado após a inicialização. Qualquer mudança aqui requer a reconstrução do índice do Elasticsearch e a reinicialização do processo de sincronização de dados.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>num_replicas</term>
      <listitem>
       <para>
        <emphasis>(número inteiro)</emphasis> O número de réplicas que será configurado no Elasticsearch na inicialização da sincronização de dados.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>explicit_custom_meta</term>
      <listitem>
       <para>
        <emphasis>(true | false) </emphasis> Especifica se todos os metadados personalizados do usuário serão indexados ou se o usuário precisará configurar (no nível do compartimento de memória) quais entradas de metadados do cliente devem ser indexadas. Por padrão, isso é “false”
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>index_buckets_list</term>
      <listitem>
       <para>
        <emphasis>(lista de strings separadas por vírgulas) </emphasis> Se vazia, todos os compartimentos de memória serão indexados. Do contrário, apenas os compartimentos de memória especificados nela serão indexados. É possível inserir prefixos (por exemplo, “foo*”) ou sufixos (por exemplo, “*bar”) de compartimento de memória.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>approved_owners_list</term>
      <listitem>
       <para>
        <emphasis>(lista de strings separadas por vírgulas)</emphasis> Se vazia, os compartimentos de memória de todos os proprietários serão indexados (sujeito a outras restrições); do contrário, apenas os compartimentos de memória pertencentes a determinados proprietários serão indexados. É possível também inserir prefixos e sufixos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>override_index_path</term>
      <listitem>
       <para>
        <emphasis>(string)</emphasis> Se não estiver vazia, essa string será usado como caminho do índice do elasticsearch. Do contrário, o caminho do índice será determinado e gerado na inicialização da sincronização.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="ceph-rgw-sync-elastic-query">
    <title>Consultas de metadados</title>
    <para>
     Como o cluster do Elasticsearch agora armazena metadados de objetos, é importante não expor o endpoint do Elasticsearch ao público e mantê-lo acessível apenas aos administradores de cluster. A própria exposição das consultas de metadados ao usuário final representa um problema, já que desejamos que o usuário consulte apenas os metadados dele, e não de quaisquer outros usuários. Para isso, o cluster do Elasticsearch deve autenticar os usuários de modo similar ao RGW, o que representa um problema.
    </para>
    <para>
     A partir do Luminous, o RGW na zona master de metadados agora pode atender às solicitações de usuários finais. Isso evita a exposição do endpoint do Elasticsearch ao público e resolve também o problema de autenticação e autorização, pois o próprio RGW pode autenticar as solicitações de usuário final. Para essa finalidade, o RGW inclui uma nova consulta nas APIs de compartimento de memória, que pode atender às solicitações do Elasticsearch. Todas essas solicitações devem ser enviadas para a zona master de metadados.
    </para>
    <variablelist>
     <varlistentry>
      <term>Obter uma consulta do Elasticsearch</term>
      <listitem>
<screen>
GET /<replaceable>BUCKET</replaceable>?query={query-expr}
       </screen>
       <para>
        parâmetros de solicitação:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          max-keys: número máx. de entradas a retornar
         </para>
        </listitem>
        <listitem>
         <para>
          marker: marcador de paginação
         </para>
        </listitem>
       </itemizedlist>
<screen>
expression := [(]&lt;arg&gt; &lt;op&gt; &lt;value&gt; [)][&lt;and|or&gt; ...]
       </screen>
       <para>
        op é um dos seguintes: &lt;, &lt;=, ==, &gt;=, &gt;
       </para>
       <para>
        Por exemplo:
       </para>
<screen>
GET /?query=name==foo
       </screen>
       <para>
        Retornará todas as chaves indexadas para as quais o usuário tem permissão de leitura e que são denominadas “foo”. A saída será uma lista de chaves em XML, que é semelhante à resposta de compartimentos de memória da lista do S3.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Configurar campos personalizados de metadados</term>
      <listitem>
       <para>
        Defina quais entradas de metadados personalizados devem ser indexadas (no compartimento de memória especificado) e quais são os tipos das chaves. Se for configurada a indexação explícita de metadados personalizados, esse procedimento será necessário para o rgw indexar os valores de metadados personalizados especificados. Do contrário, ele será necessário nos casos em que as chaves dos metadados indexados são de um tipo diferente de string.
       </para>
<screen>
POST /<replaceable>BUCKET</replaceable>?mdsearch
x-amz-meta-search: &lt;key [; type]&gt; [, ...]
       </screen>
       <para>
        Vários campos de metadados devem ser separados por vírgula. É possível forçar um tipo para um campo com “;”. Atualmente, os tipos permitidos são string (padrão), número inteiro e data. Por exemplo, para indexar os metadados de objetos personalizados x-amz-meta-year como número inteiro, x-amz-meta-date como tipo de data e x-amz-meta-title como string, você executa o seguinte
       </para>
<screen>
POST /mybooks?mdsearch
x-amz-meta-search: x-amz-meta-year;int, x-amz-meta-release-date;date, x-amz-meta-title;string
       </screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Apague a configuração de metadados personalizados</term>
      <listitem>
       <para>
        Apague a configuração de compartimento de memória dos metadados personalizados.
       </para>
<screen>
DELETE /<replaceable>BUCKET</replaceable>?mdsearch
       </screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Obter a configuração dos metadados personalizados</term>
      <listitem>
       <para>
        Recupere a configuração de compartimento de memória dos metadados personalizados.
       </para>
<screen>
GET /<replaceable>BUCKET</replaceable>?mdsearch
       </screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-ldap">
  <title>Autenticação LDAP</title>

  <para>
   Além da autenticação de usuário local padrão, o Object Gateway pode usar os serviços do servidor LDAP para autenticar também os usuários.
  </para>

  <sect2 xml:id="ceph-rgw-ldap-how-works">
   <title>Mecanismo de autenticação</title>
   <para>
    O Object Gateway extrai as credenciais de LDAP do usuário de um token. Um filtro de pesquisa é construído com base no nome de usuário. O Object Gateway usa a conta de serviço configurada para pesquisar uma entrada correspondente no diretório. Se uma entrada for encontrada, o Object Gateway tentará se vincular ao nome exclusivo encontrado com a senha do token. Se as credenciais forem válidas, o vínculo será bem-sucedido, e o Object Gateway concederá o acesso.
   </para>
   <para>
    Você pode limitar os usuários permitidos definindo a base para a pesquisa como uma unidade organizacional específica ou especificando um filtro de pesquisa personalizado. Por exemplo, exigir a participação em um grupo específico, classes de objetos ou atributos personalizados.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-reqs">
   <title>Requisitos</title>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis>LDAP ou Active Directory</emphasis>: Uma instância LDAP em execução acessível pelo Object Gateway.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>Conta de serviço</emphasis>: Credenciais LDAP para uso do Object Gateway com permissões de pesquisa.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>Conta de usuário</emphasis>: Pelo menos, uma conta do usuário no diretório LDAP.
     </para>
    </listitem>
   </itemizedlist>
   <important>
    <title>Não sobreponha usuários LDAP e locais</title>
    <para>
     Você não deve usar os mesmos nomes para usuários locais e usuários autenticados por LDAP. O Object Gateway não pode diferenciá-los e os trata como se fossem os mesmos usuários.
    </para>
   </important>
   <tip>
    <title>Verificações de integridade</title>
    <para>
     Use o utilitário <command>ldapsearch</command> para verificar a conta de serviço ou a conexão LDAP. Por exemplo:
    </para>
<screen>ldapsearch -x -D "uid=ceph,ou=system,dc=example,dc=com" -W \
-H ldaps://example.com -b "ou=users,dc=example,dc=com" 'uid=*' dn</screen>
    <para>
     Use os mesmos parâmetros LDAP que o arquivo de configuração do Ceph para evitar possíveis problemas.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-config">
   <title>Configurar o Object Gateway para usar a autenticação LDAP</title>
   <para>
    Os seguintes parâmetros no arquivo de configuração <filename>/etc/ceph/ceph.conf</filename> estão relacionados à autenticação LDAP:
   </para>
   <variablelist>
    <varlistentry>
     <term><option>rgw_ldap_uri</option>
     </term>
     <listitem>
      <para>
       Especifica o servidor LDAP a ser usado. Use o parâmetro <literal>ldaps://<replaceable>fqdn</replaceable>:<replaceable>porta</replaceable></literal> para evitar a transmissão aberta de credenciais de texto simples.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_binddn</option>
     </term>
     <listitem>
      <para>
       O DN (Distinguished Name – Nome Exclusivo) da conta de serviço usada pelo Object Gateway.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_secret</option>
     </term>
     <listitem>
      <para>
       A senha para a conta de serviço.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>rgw_ldap_searchdn</term>
     <listitem>
      <para>
       Especifica a base na árvore de informações do diretório para pesquisar usuários. Ela pode ser a unidade organizacional de usuários ou alguma OU (Organizational Unit – Unidade Organizacional) mais específica.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_dnattr</option>
     </term>
     <listitem>
      <para>
       O atributo que está sendo usado no filtro de pesquisa construído para corresponder um nome de usuário. Dependendo da DIT (Directory Information Tree – Árvore de Informações do Diretório), ele provavelmente será <literal>uid</literal> ou <literal>cn</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_search_filter</option>
     </term>
     <listitem>
      <para>
       Se não for especificado, o Object Gateway construirá automaticamente o filtro de pesquisa com a configuração <option>rgw_ldap_dnattr</option>. Use esse parâmetro para restringir a lista de usuários permitidos com muita flexibilidade. Consulte a <xref linkend="ceph-rgw-ldap-filter"/> para obter detalhes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-filter">
   <title>Usando um filtro de pesquisa personalizado para limitar o acesso do usuário</title>
   <para>
    Você pode usar o parâmetro <option>rgw_search_filter</option> de duas maneiras.
   </para>
   <sect3>
    <title>Filtro parcial para limitar ainda mais o filtro de pesquisa construído</title>
    <para>
     Veja a seguir um exemplo de filtro parcial:
    </para>
<screen>"objectclass=inetorgperson"</screen>
    <para>
     O Object Gateway gerará o filtro de pesquisa como de costume com o nome de usuário extraído do token e o valor de <option>rgw_ldap_dnattr</option>. Em seguida, o filtro construído será combinado ao filtro parcial com base no atributo <option>rgw_search_filter</option>. Dependendo do nome de usuário e das configurações, o filtro de pesquisa final poderá ser:
    </para>
<screen>"(&amp;(uid=hari)(objectclass=inetorgperson))"</screen>
    <para>
     Nesse caso, o usuário “hari” apenas receberá acesso se for encontrado no diretório LDAP, se tiver uma classe de objeto “inetorgperson” e se especificar uma senha válida.
    </para>
   </sect3>
   <sect3>
    <title>Filtro completo</title>
    <para>
     Um filtro completo deve conter um token <option>USERNAME</option> que será substituído pelo nome de usuário durante a tentativa de autenticação. O parâmetro <option>rgw_ldap_dnattr</option> não é mais usado neste caso. Por exemplo, para limitar os usuários válidos a um grupo específico, use o filtro a seguir:
    </para>
<screen>"(&amp;(uid=USERNAME)(memberOf=cn=ceph-users,ou=groups,dc=mycompany,dc=com))"</screen>
    <note>
     <title>Atributo <literal>memberOf</literal></title>
     <para>
      O uso do atributo <literal>memberOf</literal> nas pesquisas LDAP requer suporte da sua implementação de servidor LDAP específica.
     </para>
    </note>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-token">
   <title>Gerando um token de acesso para autenticação LDAP</title>
   <para>
    O utilitário <command>radosgw-token</command> gera o token de acesso com base no nome de usuário e na senha LDAP. Ele emite uma string codificada com base64, que é o token de acesso real. Use seu cliente S3 favorito (consulte a <xref linkend="accessing-ragos-gateway"/>), especifique o token como a chave de acesso e use uma chave secreta vazia.
   </para>
<screen><prompt>root@minion &gt; </prompt>export RGW_ACCESS_KEY_ID="<replaceable>username</replaceable>"
<prompt>root@minion &gt; </prompt>export RGW_SECRET_ACCESS_KEY="<replaceable>password</replaceable>"
<prompt>root@minion &gt; </prompt>radosgw-token --encode --ttype=ldap</screen>
   <important>
    <title>Credenciais de texto sem criptografia</title>
    <para>
     O token de acesso é uma estrutura JSON codificada com base64 que contém as credenciais LDAP como texto sem criptografia.
    </para>
   </important>
   <note>
    <title>Active Directory</title>
    <para>
     Para o Active Directory, use o parâmetro <option>--ttype=ad</option>.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-bucket-sharding">
  <title>Fragmentação de índice do compartimento de memória</title>

  <para>
   O Object Gateway armazena os dados de índice do compartimento de memória em um pool de índice, que assume <literal>.rgw.buckets.index</literal> como padrão. Se você colocar um número excessivo (centenas de milhares) de objetos em um único compartimento de memória, e a cota para o número máximo de objetos por compartimento de memória (<option>rgw bucket default quota max objects</option>) não for definida, o desempenho do pool de índice poderá ser prejudicado. A <emphasis>fragmentação de índice do compartimento de memória</emphasis> impede essa redução no desempenho e permite um alto número de objetos por compartimento de memória.
  </para>

  <sect2 xml:id="ogw-bucket-reshard">
   <title>Refragmentação de índice do compartimento de memória</title>
   <para>
    Se um compartimento de memória ficar muito grande e sua configuração inicial não for mais suficiente, será necessário refragmentar o pool de índice dele. Você pode usar a refragmentação de índice do compartimento de memória automática online (consulte a <xref linkend="ogw-bucket-sharding-dyn"/>) ou refragmentar o índice do compartimento de memória offline manualmente (consulte a <xref linkend="ogw-bucket-sharding-re"/>).
   </para>
   <sect3 xml:id="ogw-bucket-sharding-dyn">
    <title>Refragmentação dinâmica</title>
    <para>
     A partir do SUSE Enterprise Storage 5, oferecemos suporte à refragmentação do compartimento de memória online. Ela detecta se o número de objetos por compartimento de memória atinge determinado limite e aumenta automaticamente o número de fragmentos usados pelo índice do compartimento de memória. Esse processo reduz o número de entradas em cada fragmento de índice do compartimento de memória.
    </para>
    <para>
     O processo de detecção é executado:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Quando novos objetos são adicionados ao compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Em um processo em segundo plano que explora periodicamente todos os compartimentos de memória. Isso é necessário para resolver a questão de compartimentos de memória existentes que não são atualizados.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     Um compartimento de memória que requer refragmentação é adicionado à fila <option>reshard_log</option> e será programado para ser refragmentado posteriormente. Os threads de refragmentação são executados em segundo plano e executam a refragmentação programada, uma de cada vez.
    </para>
    <variablelist>
     <title>Configurando a refragmentação dinâmica</title>
     <varlistentry>
      <term><option>rgw_dynamic_resharding</option>
      </term>
      <listitem>
       <para>
        Habilita ou desabilita a refragmentação dinâmica de índice do compartimento de memória. Os valores possíveis são “true” (verdadeiro) ou “false” (falso). O padrão é “true”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_num_logs</option>
      </term>
      <listitem>
       <para>
        Número de fragmentos para o registro da refragmentação. O padrão é 16.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_bucket_lock_duration</option>
      </term>
      <listitem>
       <para>
        Duração do bloqueio do objeto do compartimento de memória durante a refragmentação. O padrão é 120 segundos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_max_objs_per_shard</option>
      </term>
      <listitem>
       <para>
        Número máximo de objetos por fragmento de índice do compartimento de memória. O padrão é 100.000 objetos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_thread_interval</option>
      </term>
      <listitem>
       <para>
        Tempo máxithread de refragmentaçãomo entre os ciclos de processamento do . O padrão é 600 segundos.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <important>
     <title>Configurações multissite</title>
     <para>
      A refragmentação dinâmica não é suportada em ambiente multissite. Por padrão, ela está desabilitada desde o Ceph 12.2.2, mas recomendamos conferir essa configuração.
     </para>
    </important>
    <variablelist>
     <title>Comandos para administrar o processo de refragmentação</title>
     <varlistentry>
      <term>Adicionar um compartimento de memória à fila de refragmentação:</term>
      <listitem>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin reshard add \
 --bucket <replaceable>BUCKET_NAME</replaceable> \
 --num-shards <replaceable>NEW_NUMBER_OF_SHARDS</replaceable>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Listar a fila de refragmentação:</term>
      <listitem>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin reshard list
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Processar/Programar a refragmentação de um compartimento de memória:</term>
      <listitem>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin reshard process
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Exibir o status da refragmentação do compartimento de memória:</term>
      <listitem>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin reshard status --bucket <replaceable>BUCKET_NAME</replaceable>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Cancelar uma refragmentação pendente do compartimento de memória:</term>
      <listitem>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin reshard cancel --bucket <replaceable>BUCKET_NAME</replaceable>
</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="ogw-bucket-sharding-re">
    <title>Refragmentação manual</title>
    <para>
     A refragmentação dinâmica mencionada na <xref linkend="ogw-bucket-sharding-dyn"/> é suportada apenas nas configurações simples do Object Gateway. Para configurações multissite, use a refragmentação manual descrita nesta seção.
    </para>
    <para>
     Para refragmentar o índice do compartimento de memória manualmente offline, use o seguinte comando:
    </para>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin bucket reshard
</screen>
    <para>
     O comando <command>bucket reshard</command> executa o seguinte:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Cria um novo conjunto de objetos de índice do compartimento de memória para o objeto especificado.
      </para>
     </listitem>
     <listitem>
      <para>
       Distribui todas as entradas desses objetos de índice.
      </para>
     </listitem>
     <listitem>
      <para>
       Cria uma nova instância do compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Vincula a nova instância do compartimento de memória ao compartimento de memória para que todas as novas operações de índice passem pelos novos índices do compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Imprime o ID do compartimento de memória antigo e novo para a saída padrão.
      </para>
     </listitem>
    </itemizedlist>
    <procedure>
     <title>Refragmentando o pool de índice do compartimento de memória</title>
     <step>
      <para>
       Verifique se todas as operações no compartimento de memória foram interrompidas.
      </para>
     </step>
     <step>
      <para>
       Faça backup do índice original do compartimento de memória:
      </para>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin bi list \
 --bucket=<replaceable>BUCKET_NAME</replaceable> \
 &gt; <replaceable>BUCKET_NAME</replaceable>.list.backup
</screen>
     </step>
     <step>
      <para>
       Refragmente o índice do compartimento de memória:
      </para>
<screen>
 <prompt>root@minion &gt; </prompt>radosgw-admin reshard \
 --bucket=<replaceable>BUCKET_NAME</replaceable> \
 --num-shards=<replaceable>NEW_SHARDS_NUMBER</replaceable>
</screen>
      <tip>
       <title>ID do compartimento de memória antigo</title>
       <para>
        Como parte da saída, esse comando também imprime o ID do compartimento de memória novo e antigo. Anote o ID do compartimento de memória antigo. Ele será necessário para purgar os objetos de índice do compartimento de memória antigo.
       </para>
      </tip>
     </step>
     <step>
      <para>
       Verifique se os objetos estão listados corretamente comparando a listagem de índice do compartimento de memória antigo com o novo. Em seguida, purgue os objetos de índice do compartimento de memória antigo:
      </para>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin bi purge
 --bucket=<replaceable>BUCKET_NAME</replaceable>
 --bucket-id=<replaceable>OLD_BUCKET_ID</replaceable>
</screen>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-bucket-sharding-new">
   <title>Fragmentação de índice para novos compartimentos de memória</title>
   <para>
    Há duas opções que afetam a fragmentação de índice do compartimento de memória:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Use a opção <option>rgw_override_bucket_index_max_shards</option> para configurações simples.
     </para>
    </listitem>
    <listitem>
     <para>
      Use a opção <option>bucket_index_max_shards</option> para configurações multissite.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    A definição das opções como <literal>0</literal> desabilita a fragmentação de índice do compartimento de memória. Um valor maior do que <literal>0</literal> habilita a fragmentação de índice do compartimento de memória e define o número máximo de fragmentos.
   </para>
   <para>
    A fórmula a seguir ajuda você a calcular o número recomendado de fragmentos:
   </para>
<screen>
number_of_objects_expected_in_a_bucket / 100000
</screen>
   <para>
    Esteja ciente de que o número máximo de fragmentos é 7877.
   </para>
   <sect3>
    <title>Configurações simples</title>
    <procedure>
     <step>
      <para>
       Abra o arquivo de configuração do Ceph e adicione ou modifique a seguinte opção:
      </para>
<screen>
rgw_override_bucket_index_max_shards = 12
</screen>
      <tip>
       <title>Uma ou todas as instâncias do Object Gateway</title>
       <para>
        Para configurar a fragmentação de índice do compartimento de memória para todas as instâncias do Object Gateway, inclua <option>rgw_override_bucket_index_max_shards</option> na seção <literal>[global]</literal>.
       </para>
       <para>
        Para configurar a fragmentação de índice do compartimento de memória apenas para uma instância específica do Object Gateway, inclua <option>rgw_override_bucket_index_max_shards</option> na seção relacionada da instância.
       </para>
      </tip>
     </step>
     <step>
      <para>
       Reinicie o Object Gateway. Consulte a <xref linkend="ceph-rgw-operating"/> para obter mais detalhes.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3>
    <title>Configurações multissite</title>
    <para>
     As configurações multissite podem ter um pool de índice diferente para gerenciar o failover. Para configurar um número consistente de fragmentos para as zonas em um grupo de zonas, defina a opção <option>bucket_index_max_shards</option> na configuração do grupo de zonas:
    </para>
    <procedure>
     <step>
      <para>
       Exporte a configuração do grupo de zonas para o arquivo <filename>zonegroup.json</filename>:
      </para>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin zonegroup get &gt; zonegroup.json
</screen>
     </step>
     <step>
      <para>
       Edite o arquivo <filename>zonegroup.json</filename> e defina a opção <option>bucket_index_max_shards</option> para cada zona nomeada.
      </para>
     </step>
     <step>
      <para>
       Redefina o grupo de zonas:
      </para>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin zonegroup set &lt; zonegroup.json
</screen>
     </step>
     <step>
      <para>
       Atualize o período:
      </para>
<screen>
<prompt>root@minion &gt; </prompt>radosgw-admin period update --commit
</screen>
     </step>
    </procedure>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-keystone">
  <title>Integrando o OpenStack Keystone</title>

  <para>
   O OpenStack Keystone é um serviço de identidade que faz parte do produto OpenStack. Você pode integrar o Object Gateway ao Keystone para configurar um gateway que aceita o token de autenticação do Keystone. Um usuário autorizado pelo Keystone a acessar o gateway será verificado no Ceph Object Gateway e criado automaticamente, se necessário. O Object Gateway consulta o Keystone periodicamente para obter uma lista de tokens revogados.
  </para>

  <sect2 xml:id="ogw-keystone-ostack">
   <title>Configurando o OpenStack</title>
   <para>
    Antes de configurar o Ceph Object Gateway, você precisa configurar o OpenStack Keystone para habilitar o serviço Swift e apontá-lo para o Ceph Object Gateway:
   </para>
   <procedure>
    <step>
     <para>
      <emphasis>Defina o serviço Swift.</emphasis> Para usar o OpenStack para validar usuários do Swift, crie primeiro o serviço Swift:
     </para>
<screen>
<prompt>root # </prompt>openstack service create \
 --name=swift \
 --description="Swift Service" \
 object-store
</screen>
    </step>
    <step>
     <para>
      <emphasis>Defina os endpoints.</emphasis> Após criar o serviço Swift, aponte para o Ceph Object Gateway. Substitua <replaceable>REGION_NAME</replaceable> pelo nome do grupo de zonas ou da região do gateway.
     </para>
<screen>
<prompt>root # </prompt>openstack endpoint create --region <replaceable>REGION_NAME</replaceable> \
 --publicurl   "http://radosgw.example.com:8080/swift/v1" \
 --adminurl    "http://radosgw.example.com:8080/swift/v1" \
 --internalurl "http://radosgw.example.com:8080/swift/v1" \
 swift
</screen>
    </step>
    <step>
     <para>
      <emphasis>Verifique as configurações.</emphasis> Após criar o serviço Swift e definir os endpoints, mostre os endpoints para verificar se todas as configurações estão corretas.
     </para>
<screen>
<prompt>root # </prompt>openstack endpoint show object-store
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-keystone-ogw">
   <title>Configurando o Ceph Object Gateway</title>
   <sect3>
    <title>Configurar certificados SSL</title>
    <para>
     O Ceph Object Gateway consulta o Keystone periodicamente para obter uma lista de tokens revogados. Essas solicitações são codificadas e assinadas. É possível também configurar o Keystone para fornecer tokens autoassinados, que também são codificados e assinados. Você precisa configurar o gateway para que possa decodificar e verificar essas mensagens assinadas. Portanto, os certificados OpenSSL que o Keystone usa para criar as solicitações precisam ser convertidos no formato “nss db”:
    </para>
<screen>
<prompt>root # </prompt>mkdir /var/ceph/nss
<prompt>root # </prompt>openssl x509 -in /etc/keystone/ssl/certs/ca.pem \
 -pubkey | certutil -d /var/ceph/nss -A -n ca -t "TCu,Cu,Tuw"
<systemitem class="username">root</systemitem>openssl x509 -in /etc/keystone/ssl/certs/signing_cert.pem \
 -pubkey | certutil -A -d /var/ceph/nss -n signing_cert -t "P,P,P"
</screen>
    <para>
     É possível também terminar o OpenStack Keystone com um certificado SSL autoassinado para o Ceph Object Gateway interagir com o Keystone. Instale o certificado SSL do Keystone no nó que executa o Ceph Object Gateway ou, se preferir, defina o valor da opção <option>rgw keystone verify ssl</option> como “false”. A definição de <option>rgw keystone verify ssl</option> como “false” indica que o gateway não tentará verificar o certificado.
    </para>
   </sect3>
   <sect3>
    <title>Configurar as opções do Object Gateway</title>
    <para>
     Você pode configurar a integração com o Keystone usando as seguintes opções:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone api version</option>
      </term>
      <listitem>
       <para>
        Versão da API do Keystone. As opções válidas são 2 ou 3. O padrão é 2.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone url</option>
      </term>
      <listitem>
       <para>
        O URL e o número da porta da API RESTful administrativa no servidor Keystone. Segue o padrão <replaceable>URL_SERVIDOR:NÚMERO_DA_PORTA</replaceable>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin token</option>
      </term>
      <listitem>
       <para>
        O token ou segredo compartilhado configurado internamente no Keystone para solicitações administrativas.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone accepted roles</option>
      </term>
      <listitem>
       <para>
        As funções necessárias para atender às solicitações. O padrão é “Member, admin”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone accepted admin roles</option>
      </term>
      <listitem>
       <para>
        A lista de funções que permite a um usuário obter privilégios administrativos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone token cache size</option>
      </term>
      <listitem>
       <para>
        O número máximo de entradas no cache de token do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone revocation interval</option>
      </term>
      <listitem>
       <para>
        O número de segundos antes de verificar se há tokens revogados. O padrão é 15 * 60.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone implicit tenants</option>
      </term>
      <listitem>
       <para>
        Criar novos usuários em seus próprios locatários de mesmo nome. O padrão é “false”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw s3 auth use keystone</option>
      </term>
      <listitem>
       <para>
        Se definido como “true”, o Ceph Object Gateway autenticará os usuários com o Keystone. O padrão é “false”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>nss db path</option>
      </term>
      <listitem>
       <para>
        O caminho para o banco de dados NSS.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Também é possível configurar o locatário de serviço do Keystone, usuário e senha do Keystone (para a versão 2.0 da API do OpenStack Identity), similar ao modo como os serviços do OpenStack costumam ser configurados. Dessa forma, você pode evitar a definição do segredo compartilhado <option>rgw keystone admin token</option> no arquivo de configuração, que deve ser desabilitado em ambientes de produção. As credenciais do locatário de serviço devem ter privilégios de admin. Para obter mais detalhes, consulte a <link xlink:href="https://docs.openstack.org/keystone/latest/#setting-up-projects-users-and-roles">documentação oficial do OpenStack Keystone</link>. Veja a seguir as opções de configuração relacionadas:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone admin user</option>
      </term>
      <listitem>
       <para>
        Nome do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin password</option>
      </term>
      <listitem>
       <para>
        Senha do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin tenant</option>
      </term>
      <listitem>
       <para>
        Locatário do usuário administrador do Keystone versão 2.0.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Um usuário do Ceph Object Gateway é mapeado para um locatário do Keystone. Um usuário do Keystone tem funções diferentes atribuídas, possivelmente em mais do que um único locatário. Quando o Ceph Object Gateway recebe o ticket, ele examina o locatário e as funções do usuário atribuídas a esse ticket e aceita ou rejeita a solicitação de acordo com a configuração da opção <option>rgw keystone accepted roles</option>.
    </para>
    <tip>
     <title>Mapeando locatários do OpenStack</title>
     <para>
      Embora os locatários do Swift sejam mapeados para o usuário do Object Gateway por padrão, eles também podem ser mapeados para os locatários do OpenStack por meio da opção <option>rgw keystone implicit tenants</option>. Isso fará com que os containers usem o namespace do locatário em vez do namespace global do tipo do S3 que o Object Gateway usa como padrão. É recomendável decidir sobre o método de mapeamento na fase de planejamento para evitar confusão. O motivo é que alternar a opção posteriormente afeta apenas as solicitações mais recentes que são mapeadas em um locatário, enquanto os compartimentos de memória mais antigos criados antes ainda continuam em um namespace global.
     </para>
    </tip>
    <para>
     Para obter a versão 3 da API do OpenStack Identity, você deve substituir a opção <option>rgw keystone admin tenant</option> por:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone admin domain</option>
      </term>
      <listitem>
       <para>
        Domínio do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin project</option>
      </term>
      <listitem>
       <para>
        Projeto do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-fed">


  <title>Object Gateways multissite</title>

  <variablelist>
   <varlistentry>
    <term>Zona</term>
    <listitem>
     <para>
      Um agrupamento lógico de uma ou mais instâncias do Object Gateway. Deve haver uma zona designada como <emphasis>master</emphasis> em um <emphasis>grupo de zonas</emphasis>, que processa toda a criação de compartimento de memória e usuário.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Grupo de zonas</term>
    <listitem>
     <para>
      Um grupo de zonas consiste em várias zonas. Deve haver um grupo de zonas master que processará as mudanças na configuração do sistema.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Mapa de grupo de zonas</term>
    <listitem>
     <para>
      Uma estrutura de configuração que contém o mapa de todo o sistema. Por exemplo, que grupo de zonas é master, os relacionamentos entre diferentes grupos de zonas e determinadas opções de configuração, como políticas de armazenamento.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Domínio</term>
    <listitem>
     <para>
      Um container para grupos de zonas. Ele permite a separação de grupos de zonas entre clusters. É possível criar vários domínios, facilitando a execução de configurações completamente diferentes no mesmo cluster.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Período</term>
    <listitem>
     <para>
      Um período contém a estrutura de configuração para o estado atual do domínio. Cada período contém um ID e uma época exclusivos. Cada domínio tem um período atual associado, que contém o estado atual da configuração dos grupos de zonas e das políticas de armazenamento. Qualquer mudança na configuração para uma zona não master incrementará a época do período. Modificar a zona master para uma zona diferente acionará as seguintes mudanças:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        Um novo período será gerado com um novo ID e época do período de 1.
       </para>
      </listitem>
      <listitem>
       <para>
        O período atual do domínio será atualizado para apontar para o ID do período recém-gerado.
       </para>
      </listitem>
      <listitem>
       <para>
        A época do domínio será incrementada.
       </para>
      </listitem>
     </itemizedlist>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Você pode configurar cada Object Gateway para participar de uma arquitetura unificada, trabalhando em uma configuração de zona ativa e permitindo gravações em zonas não master.
  </para>

  <sect2 xml:id="ceph-rgw-fed-term">
   <title>Terminologia</title>
   <para>
    Veja a seguir uma descrição dos termos específicos de uma arquitetura unificada:
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-intro">
   <title>Configuração de cluster de exemplo</title>
   <para>
    Neste exemplo, o foco será na criação de um único grupo de zonas com três zonas separadas, que sincronizam seus dados ativamente. Duas zonas pertencem ao mesmo cluster, enquanto a terceira pertence a outro. Não há um agente de sincronização envolvido no espelhamento das mudanças de dados entre os Object Gateways. Isso possibilita um esquema de configuração muito mais simples e configurações ativas-ativas. Observe que as operações de metadados, como a criação de um novo usuário, ainda precisam passar pela zona master. No entanto, as operações de dados, como criação de objetos e compartimentos de memória, podem ser gerenciadas por qualquer uma das zonas.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-keys">
   <title>Chaves do sistema</title>
   <para>
    Ao configurar as zonas, o Object Gateway espera a criação de um usuário do sistema compatível com S3 juntamente com as chaves secretas e de acesso. Isso permite que outra instância do Object Gateway extraia a configuração remotamente com as chaves secretas e de acesso. Para obter mais informações sobre como criar usuários do S3, consulte a <xref linkend="adding-s3-swift-users"/>.
   </para>
   <tip>
    <para>
     Isso é útil para gerar as chaves secretas e de acesso antes da criação da própria zona, pois facilita a criação de scripts e o uso das ferramentas de gerenciamento de configuração no futuro.
    </para>
   </tip>
   <para>
    Para efeitos deste exemplo, vamos supor que as chaves secretas e de acesso foram definidas nas variáveis de ambiente:
   </para>
<screen># SYSTEM_ACCESS_KEY=1555b35654ad1656d805
# SYSTEM_SECRET_KEY=h7GhxuBLTrlhVUyxSPUKUV8r/2EI4ngqJxD7iBdBYLhwluN30JaT3Q==</screen>
   <para>
    Normalmente, as chaves de acesso são compostas por 20 caracteres alfanuméricos, enquanto as chaves secretas são constituídas de 40 caracteres alfanuméricos (também podem conter os caracteres +/=). É possível gerar essas chaves na linha de comando:
   </para>
<screen># SYSTEM_ACCESS_KEY=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 20 | head -n 1)
# SYSTEM_SECRET_KEY=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 40 | head -n 1)</screen>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-naming">
   <title>Convenções de nomeação</title>
   <para>
    Este exemplo descreve o processo de configuração de uma zona master. Vamos considerar um grupo de zonas denominado <literal>us</literal> abrangendo os Estados Unidos, que será nosso grupo de zonas master. Ele incluirá duas zonas gravadas no formato <replaceable>grupodezonas</replaceable>-<replaceable>zona</replaceable>. Trata-se apenas da nossa convenção, e você pode escolher o formato de sua preferência. Em resumo:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Grupo de zonas master: Estados Unidos <literal>us</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Zona master: Estados Unidos, Região Leste 1: <literal>us-east-1</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Zona secundária: Estados Unidos, Região Leste 2: <literal>us-east-2</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Zona secundária: Estados Unidos, Região Oeste: <literal>us-west</literal>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Isso fará parte de um domínio maior denominado <literal>gold</literal>. As zonas <literal>us-east-1</literal> e <literal>us-east-2</literal> fazem parte do mesmo cluster do Ceph, sendo <literal>us-east-1</literal> a primária. <literal>us-west</literal> está em um cluster diferente do Ceph.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-pools">
   <title>Pools padrão</title>
   <para>
    Quando configurado com as permissões apropriadas, o próprio Object Gateway cria pools padrão. Os valores <literal>pg_num</literal> e <literal>pgp_num</literal> são obtidos do arquivo de configuração <filename>ceph.conf</filename>. Por padrão, os pools relacionados a uma zona seguem a convenção <replaceable>nome-zona</replaceable>.<replaceable>nome-pool</replaceable>. Por exemplo, para a zona <literal>us-east-1</literal>, serão os seguintes pools:
   </para>
<screen>.rgw.root
us-east-1.rgw.control
us-east-1.rgw.data.root
us-east-1.rgw.gc
us-east-1.rgw.log
us-east-1.rgw.intent-log
us-east-1.rgw.usage
us-east-1.rgw.users.keys
us-east-1.rgw.users.email
us-east-1.rgw.users.swift
us-east-1.rgw.users.uid
us-east-1.rgw.buckets.index
us-east-1.rgw.buckets.data
us-east-1.rgw.meta</screen>
   <para>
    Esses pools também podem ser criados em outras zonas substituindo <literal>us-east-1</literal> pelo nome da zona apropriado.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-realm">
   <title>Criando um domínio</title>
   <para>
    Configure um domínio chamado <literal>gold</literal> e torne-o o domínio padrão:
   </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin realm create --rgw-realm=gold --default
{
  "id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "name": "gold",
  "current_period": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "epoch": 1
}</screen>
   <para>
    Observe que cada domínio tem um ID, que permite flexibilidade, como renomear um domínio no futuro, se necessário. <literal>current_period</literal> muda sempre que alguma coisa é modificada na zona master. <literal>epoch</literal> é incrementado quando há alguma mudança na configuração da zona master que resulta na mudança do período atual.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-deldefzonegrp">
   <title>Apagando o grupo de zonas padrão</title>
   <para>
    A instalação padrão do Object Gateway cria o grupo de zonas padrão chamado <literal>default</literal>. Como não precisamos mais do grupo de zonas padrão, remova-o.
   </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zonegroup delete --rgw-zonegroup=default</screen>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-createmasterzonegrp">
   <title>Criando um grupo de zonas master</title>
   <para>
    Crie um grupo de zonas master chamado <literal>us</literal>. O grupo de zonas gerenciará o mapa de grupo de zonas e propagará as mudanças para o restante do sistema. Ao marcar o grupo de zonas como padrão, você permite mencionar explicitamente o switch rgw-zonegroup para comandos futuros.
   </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zonegroup create --rgw-zonegroup=us \
--endpoints=http://rgw1:80 --master --default
{
  "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "name": "us",
  "api_name": "us",
  "is_master": "true",
  "endpoints": [
      "http:\/\/rgw1:80"
  ],
  "hostnames": [],
  "hostnames_s3website": [],
  "master_zone": "",
  "zones": [],
  "placement_targets": [],
  "default_placement": "",
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
}</screen>
   <para>
    Se preferir, você poderá marcar um grupo de zonas como padrão com o seguinte comando:
   </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zonegroup default --rgw-zonegroup=us</screen>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-masterzone">
   <title>Criando uma zona master</title>
   <para>
    Agora, crie uma zona padrão e adicione-a ao grupo de zonas padrão. Observe que você usará essa zona para operações de metadados, como criação de usuário:
   </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --rgw-zone=us-east-1 \
--endpoints=http://rgw1:80 --access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable>
{
  "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "name": "us-east-1",
  "domain_root": "us-east-1/gc.rgw.data.root",
  "control_pool": "us-east-1/gc.rgw.control",
  "gc_pool": "us-east-1/gc.rgw.gc",
  "log_pool": "us-east-1/gc.rgw.log",
  "intent_log_pool": "us-east-1/gc.rgw.intent-log",
  "usage_log_pool": "us-east-1/gc.rgw.usage",
  "user_keys_pool": "us-east-1/gc.rgw.users.keys",
  "user_email_pool": "us-east-1/gc.rgw.users.email",
  "user_swift_pool": "us-east-1/gc.rgw.users.swift",
  "user_uid_pool": "us-east-1/gc.rgw.users.uid",
  "system_key": {
      "access_key": "1555b35654ad1656d804",
      "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r\/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
  },
  "placement_pools": [
      {
          "key": "default-placement",
          "val": {
              "index_pool": "us-east-1/gc.rgw.buckets.index",
              "data_pool": "us-east-1/gc.rgw.buckets.data",
              "data_extra_pool": "us-east-1/gc.rgw.buckets.non-ec",
              "index_type": 0
          }
      }
  ],
  "metadata_heap": "us-east-1/gc.rgw.meta",
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
}</screen>
   <para>
    Observe que os switches <option>--rgw-zonegroup</option> e <option>--default</option> adicionam a zona a um grupo de zonas e a tornam padrão. Se preferir, o mesmo também pode ser feito com os seguintes comandos:
   </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zone default --rgw-zone=us-east-1
<prompt>cephadm &gt; </prompt>radosgw-admin zonegroup add --rgw-zonegroup=us --rgw-zone=us-east-1</screen>
   <sect3 xml:id="ceph-rgw-fed-masterzone-createuser">
    <title>Criando usuários do sistema</title>
    <para>
     Para acessar os pools da zona, você precisa criar um usuário do sistema. Observe que você também precisará dessas chaves durante a configuração da zona secundária.
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin user create --uid=zone.user \
--display-name="Zone User" --access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> \
--secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable> --system</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone-updateperiod">
    <title>Atualizar o período</title>
    <para>
     Como você mudou a configuração da zona master, precisa confirmar as modificações para que elas entrem em vigor na estrutura de configuração do domínio. Inicialmente, o período tem esta aparência:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin period get
{
  "id": "09559832-67a4-4101-8b3f-10dfcd6b2707", "epoch": 1, "predecessor_uuid": "", "sync_status": [], "period_map":
  {
    "id": "09559832-67a4-4101-8b3f-10dfcd6b2707", "zonegroups": [], "short_zone_ids": []
  }, "master_zonegroup": "", "master_zone": "", "period_config":
  {
     "bucket_quota": {
     "enabled": false, "max_size_kb": -1, "max_objects": -1
     }, "user_quota": {
       "enabled": false, "max_size_kb": -1, "max_objects": -1
     }
  }, "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7", "realm_name": "gold", "realm_epoch": 1
}</screen>
    <para>
     Atualize o período e confirme as mudanças:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin period update --commit
{
  "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 1,
  "predecessor_uuid": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "sync_status": [ "[...]"
  ],
  "period_map": {
      "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
      "zonegroups": [
          {
              "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
              "name": "us",
              "api_name": "us",
              "is_master": "true",
              "endpoints": [
                  "http:\/\/rgw1:80"
              ],
              "hostnames": [],
              "hostnames_s3website": [],
              "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "zones": [
                  {
                      "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
                      "name": "us-east-1",
                      "endpoints": [
                          "http:\/\/rgw1:80"
                      ],
                      "log_meta": "true",
                      "log_data": "false",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  }
              ],
              "placement_targets": [
                  {
                      "name": "default-placement",
                      "tags": []
                  }
              ],
              "default_placement": "default-placement",
              "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
          }
      ],
      "short_zone_ids": [
          {
              "key": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "val": 630926044
          }
      ]
  },
  "master_zonegroup": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "period_config": {
      "bucket_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      },
      "user_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      }
  },
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "realm_name": "gold",
  "realm_epoch": 2
}</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone-startrgw">
    <title>Iniciar o Object Gateway</title>
    <para>
     É necessário mencionar as opções de zona e porta do Object Gateway no arquivo de configuração antes de iniciá-lo. Para obter mais informações sobre o Object Gateway e sua configuração, consulte o <xref linkend="cha-ceph-gw"/>. A seção de configuração do Object Gateway deve ser semelhante a esta:
    </para>
<screen>[client.rgw.us-east-1]
rgw_frontends="civetweb port=80"
rgw_zone=us-east-1</screen>
    <para>
     Inicie o Object Gateway:
    </para>
<screen>sudo systemctl start ceph-radosgw@rgw.us-east-1</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-secondaryzone">
   <title>Criando uma zona secundária</title>
   <para>
    No mesmo cluster, crie e configure a zona secundária chamada <literal>us-east-2</literal>. Você pode executar todos os comandos a seguir no nó que hospeda a própria zona master.
   </para>
   <para>
    Para criar a zona secundária, execute o mesmo comando de quando você criou a zona primária, mas descartando o flag de master:
   </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --endpoints=http://rgw2:80 \
--rgw-zone=us-east-2 --access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable>
{
  "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
  "name": "us-east-2",
  "domain_root": "us-east-2.rgw.data.root",
  "control_pool": "us-east-2.rgw.control",
  "gc_pool": "us-east-2.rgw.gc",
  "log_pool": "us-east-2.rgw.log",
  "intent_log_pool": "us-east-2.rgw.intent-log",
  "usage_log_pool": "us-east-2.rgw.usage",
  "user_keys_pool": "us-east-2.rgw.users.keys",
  "user_email_pool": "us-east-2.rgw.users.email",
  "user_swift_pool": "us-east-2.rgw.users.swift",
  "user_uid_pool": "us-east-2.rgw.users.uid",
  "system_key": {
      "access_key": "1555b35654ad1656d804",
      "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r\/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
  },
  "placement_pools": [
      {
          "key": "default-placement",
          "val": {
              "index_pool": "us-east-2.rgw.buckets.index",
              "data_pool": "us-east-2.rgw.buckets.data",
              "data_extra_pool": "us-east-2.rgw.buckets.non-ec",
              "index_type": 0
          }
      }
  ],
  "metadata_heap": "us-east-2.rgw.meta",
  "realm_id": "815d74c2-80d6-4e63-8cfc-232037f7ff5c"
}</screen>
   <sect3 xml:id="ceph-rgw-fed-secondzone-updateperiod">
    <title>Atualizar o período</title>
    <para>
     Informe todos os gateways sobre a nova mudança no mapa do sistema fazendo uma atualização do período e confirmando as modificações:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin period update --commit
{
  "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 2,
  "predecessor_uuid": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "sync_status": [ "[...]"
  ],
  "period_map": {
      "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
      "zonegroups": [
          {
              "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
              "name": "us",
              "api_name": "us",
              "is_master": "true",
              "endpoints": [
                  "http:\/\/rgw1:80"
              ],
              "hostnames": [],
              "hostnames_s3website": [],
              "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "zones": [
                  {
                      "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
                      "name": "us-east-1",
                      "endpoints": [
                          "http:\/\/rgw1:80"
                      ],
                      "log_meta": "true",
                      "log_data": "false",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  },
                  {
                      "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
                      "name": "us-east-2",
                      "endpoints": [
                          "http:\/\/rgw2:80"
                      ],
                      "log_meta": "false",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  }

              ],
              "placement_targets": [
                  {
                      "name": "default-placement",
                      "tags": []
                  }
              ],
              "default_placement": "default-placement",
              "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
          }
      ],
      "short_zone_ids": [
          {
              "key": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "val": 630926044
          },
          {
              "key": "950c1a43-6836-41a2-a161-64777e07e8b8",
              "val": 4276257543
          }

      ]
  },
  "master_zonegroup": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "period_config": {
      "bucket_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      },
      "user_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      }
  },
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "realm_name": "gold",
  "realm_epoch": 2
}</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-secondzone-startrgw">
    <title>Iniciar o Object Gateway</title>
    <para>
     Ajuste a configuração do Object Gateway para a zona secundária e inicie-o:
    </para>
<screen>[client.rgw.us-east-2]
rgw_frontends="civetweb port=80"
rgw_zone=us-east-2</screen>
<screen><prompt>cephadm &gt; </prompt>sudo systemctl start ceph-radosgw@rgw.us-east-2</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-seccluster">
   <title>Adicionando o Object Gateway ao segundo cluster</title>
   <para>
    O segundo cluster do Ceph pertence ao mesmo grupo de zonas que o inicial, mas pode estar geograficamente em qualquer outro lugar.
   </para>
   <sect3 xml:id="ceph-rgw-fed-seccluster-realm">
    <title>Domínio padrão e grupo de zonas</title>
    <para>
     Como você já criou o domínio para o primeiro gateway, insira-o aqui e torne-o padrão:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin realm pull --url=http://rgw1:80 \
--access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable>
{
  "id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "name": "gold",
  "current_period": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 2
}
<prompt>cephadm &gt; </prompt>radosgw-admin realm default --rgw-realm=gold</screen>
    <para>
     Obtenha a configuração da zona master extraindo o período:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin period pull --url=http://rgw1:80 \
--access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable></screen>
    <para>
     Defina o grupo de zonas padrão como o grupo <literal>us</literal> já criado:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zonegroup default --rgw-zonegroup=us</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-seccluster-seczone">
    <title>Configuração da zona secundária</title>
    <para>
     Crie uma nova zona chamada <literal>us-west</literal> com as mesmas chaves do sistema:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --rgw-zone=us-west \
--access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable> \
--endpoints=http://rgw3:80 --default
{
  "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
  "name": "us-west",
  "domain_root": "us-west.rgw.data.root",
  "control_pool": "us-west.rgw.control",
  "gc_pool": "us-west.rgw.gc",
  "log_pool": "us-west.rgw.log",
  "intent_log_pool": "us-west.rgw.intent-log",
  "usage_log_pool": "us-west.rgw.usage",
  "user_keys_pool": "us-west.rgw.users.keys",
  "user_email_pool": "us-west.rgw.users.email",
  "user_swift_pool": "us-west.rgw.users.swift",
  "user_uid_pool": "us-west.rgw.users.uid",
  "system_key": {
      "access_key": "1555b35654ad1656d804",
      "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r\/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
  },
  "placement_pools": [
      {
          "key": "default-placement",
          "val": {
              "index_pool": "us-west.rgw.buckets.index",
              "data_pool": "us-west.rgw.buckets.data",
              "data_extra_pool": "us-west.rgw.buckets.non-ec",
              "index_type": 0
          }
      }
  ],
  "metadata_heap": "us-west.rgw.meta",
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
}</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-seccluster-period">
    <title>Atualizar o período</title>
    <para>
     Para propagar as mudanças do mapa de grupo de zonas, atualizamos e confirmamos o período:
    </para>
<screen><prompt>cephadm &gt; </prompt>radosgw-admin period update --commit --rgw-zone=us-west
{
  "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 3,
  "predecessor_uuid": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "sync_status": [
      "", # truncated
  ],
  "period_map": {
      "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
      "zonegroups": [
          {
              "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
              "name": "us",
              "api_name": "us",
              "is_master": "true",
              "endpoints": [
                  "http:\/\/rgw1:80"
              ],
              "hostnames": [],
              "hostnames_s3website": [],
              "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "zones": [
                  {
                      "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
                      "name": "us-east-1",
                      "endpoints": [
                          "http:\/\/rgw1:80"
                      ],
                      "log_meta": "true",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  },
                                  {
                      "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
                      "name": "us-east-2",
                      "endpoints": [
                          "http:\/\/rgw2:80"
                      ],
                      "log_meta": "false",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  },
                  {
                      "id": "d9522067-cb7b-4129-8751-591e45815b16",
                      "name": "us-west",
                      "endpoints": [
                          "http:\/\/rgw3:80"
                      ],
                      "log_meta": "false",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  }
              ],
              "placement_targets": [
                  {
                      "name": "default-placement",
                      "tags": []
                  }
              ],
              "default_placement": "default-placement",
              "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
          }
      ],
      "short_zone_ids": [
          {
              "key": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "val": 630926044
          },
          {
              "key": "950c1a43-6836-41a2-a161-64777e07e8b8",
              "val": 4276257543
          },
          {
              "key": "d9522067-cb7b-4129-8751-591e45815b16",
              "val": 329470157
          }
      ]
  },
  "master_zonegroup": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "period_config": {
      "bucket_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      },
      "user_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      }
  },
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "realm_name": "gold",
  "realm_epoch": 2
}</screen>
    <para>
     Observe que o número da época do período foi incrementado, o que indica uma mudança na configuração.
    </para>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-seccluster-rgwstart">
    <title>Iniciar o Object Gateway</title>
    <para>
     O procedimento é quase igual a iniciar o Object Gateway na primeira zona. A única diferença é que a configuração da zona do Object Gateway deve refletir o nome da zona <literal>us-west</literal>:
    </para>
<screen>[client.rgw.us-west]
rgw_frontends="civetweb port=80"
rgw_zone=us-west</screen>
    <para>
     Inicie o segundo Object Gateway:
    </para>
<screen>sudo systemctl start ceph-radosgw@rgw.us-west</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-failover">
   <title>Failover e recuperação de desastre</title>
   <para>
    Se a zona master falhar, faça o failover para a zona secundária para recuperação de desastre.
   </para>
   <procedure>
    <step>
     <para>
      Converta a zona secundária na zona master e padrão. Por exemplo:
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> zone modify --rgw-zone={zone-name} --master --default
     </screen>
     <para>
      Por padrão, o Ceph Object Gateway será executado em uma configuração ativa-ativa. Se o cluster foi configurado para ser executado em uma configuração ativa-passiva, a zona secundária é uma zona apenas leitura. Remova o status --read-only para permitir que a zona receba as operações de gravação. Por exemplo:
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> zone modify --rgw-zone={zone-name} --master --default \
--read-only=False
     </screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor.
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> period update --commit
     </screen>
    </step>
    <step>
     <para>
      Por fim, reinicie o Ceph Object Gateway.
     </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> restart ceph-radosgw@rgw.`hostname -s`
     </screen>
    </step>
   </procedure>
   <para>
    Se a zona master anterior for recuperada, reverta a operação.
   </para>
   <procedure>
    <step>
     <para>
      Da zona recuperada, extraia o período da zona master atual.
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> period pull --url={url-to-master-zone-gateway} \
--access-key={access-key} --secret={secret}
     </screen>
    </step>
    <step>
     <para>
      Converta a zona recuperada na zona master e padrão.
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> zone modify --rgw-zone={zone-name} --master --default
     </screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor.
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> period update --commit
     </screen>
    </step>
    <step>
     <para>
      Em seguida, reinicie o Ceph Object Gateway na zona recuperada.
     </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> restart ceph-radosgw@rgw.`hostname -s`
     </screen>
    </step>
    <step>
     <para>
      Se a zona secundária precisar de uma configuração apenas leitura, atualize-a.
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> zone modify --rgw-zone={zone-name} --read-only
     </screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor.
     </para>
<screen>
<prompt>root # </prompt><command>radosgw-admin</command> period update --commit
     </screen>
    </step>
    <step>
     <para>
      Por fim, reinicie o Ceph Object Gateway na zona secundária.
     </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> restart ceph-radosgw@rgw.`hostname -s`
     </screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-haproxy">
  <title>Equilibrando a carga dos servidores Object Gateway com HAProxy</title>

  <para>
   Você pode usar o balanceador de carga HAProxy para distribuir todas as solicitações entre os vários servidores Object Gateway de back end. Consulte <link xlink:href="https://www.suse.com/documentation/sle-ha-12/book_sleha/data/sec_ha_lb_haproxy.html"/> para obter mais detalhes sobre como configurar o HAProxy.
  </para>

  <para>
   Veja a seguir uma configuração simples do HAProxy para equilibrar os nós do Object Gateway usando o rodízio como algoritmo de equilíbrio:
  </para>

<screen>
<prompt>root # </prompt>cat /etc/haproxy/haproxy.cfg
[...]
frontend <replaceable>https_frontend</replaceable>
bind *:443 crt <replaceable>path-to-cert.pem</replaceable> [ciphers: ... ]
default_backend rgw

backend rgw
mode http
balance roundrobin
server rgw_server1 <replaceable>rgw-endpoint1</replaceable> weight 1 maxconn 100 check
server rgw_server2 <replaceable>rgw-endpoint2</replaceable> weight 1 maxconn 100 check
[...]
</screen>
 </sect1>
</chapter>
